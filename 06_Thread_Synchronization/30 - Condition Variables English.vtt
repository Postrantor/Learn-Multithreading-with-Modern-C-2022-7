WEBVTT

0
00:00.240 --> 00:00.880
Hello again.

1
00:01.110 --> 00:07.980
In this video, we are going to look at condition variables.
A common problem that occurs in many

2
00:07.980 --> 00:11.490
workplaces, even including software development.

3
00:12.720 --> 00:18.000
You are ready to start work, but you cannot actually do anything yet because you need something from

4
00:18.000 --> 00:18.690
someone else.

5
00:19.470 --> 00:25.960
They need to finish what they are doing or they need to do something or some kind of event needs to occur.

6
00:27.580 --> 00:34.840
A common solution to this is to have someone such as a foreman or a supervisor who can coordinate the

7
00:34.840 --> 00:35.810
different workers.

8
00:37.480 --> 00:42.790
So, for example, if we have person A who is doing some work and person B is waiting for something

9
00:42.790 --> 00:43.780
from person A.

10
00:45.190 --> 00:51.010
Then person A finishes their work and then they communicate with the foreman to say that they have

11
00:51.550 --> 01:00.130
finished what is needed. Then the foreman will signal to person B and then person B can start doing

12
01:00.130 --> 01:00.640
their work.

13
01:04.620 --> 01:10.950
And we often get this situation in threaded programs as well, a thread has to wait for another thread

14
01:10.950 --> 01:18.270
to return some data or to do something or for an event to occur before the first thread can proceed.

15
01:19.860 --> 01:24.160
If we consider we have a program which is fetching some data over the network.

16
01:24.570 --> 01:26.310
This could start up some threads.

17
01:26.610 --> 01:29.680
It could start up one thread, which actually fetches the data.

18
01:30.780 --> 01:35.700
Another thread which displays a progress bar. This thread will monitor the data as it comes in.

19
01:36.000 --> 01:41.910
And from time to time, it will update itself. And then another threat which will process the data.

20
01:43.530 --> 01:49.440
When all the data has been received, the thread that is fetching the data will terminate. The thread

21
01:49.440 --> 01:51.600
with the progress bar will also terminate.

22
01:52.350 --> 01:55.830
And then the thread which is going to process this data, will be able to run.

23
01:58.030 --> 02:03.940
So you might want to pause the video for a moment and think about how you might implement this.

24
02:08.390 --> 02:14.570
Well, one solution is to use a boolean variable, which will be shared and can be seen by all the threads.

25
02:15.670 --> 02:20.960
This will be set to true when all the data has been fetched and before that, it will be false.

26
02:21.760 --> 02:25.150
So the fetching thread will set this to true when it finishes.

27
02:27.130 --> 02:32.520
And the other threads will check this flag so they can tell with the data has been fetched or not.

28
02:33.830 --> 02:39.890
Obviously, this will need to be protected by a mutex to avoid a data race, because we can have multiple threads

29
02:40.220 --> 02:43.910
which are accessing this variable and the possibility of modification.

30
02:46.090 --> 02:51.460
So we would do this by having loops in the progress bar thread and the processing thread. These will check

31
02:51.460 --> 02:55.960
the variable and when the variable becomes true, these loops will terminate.

32
02:57.040 --> 03:03.190
And the progress bar thread will exit and the processing thread will start doing its processing.

33
03:04.780 --> 03:08.050
This will work and it is thread-safe, but it is not very efficient.

34
03:10.160 --> 03:15.320
These loops in the waiting threads are going to spin around using up lots of CPU cycles.

35
03:16.690 --> 03:21.360
And also, while these threads are checking the flag, they will have a lock on the mutex and that will

36
03:21.470 --> 03:24.400
prevent the fetching thread from setting the flag.

37
03:26.230 --> 03:32.290
The loops do not have to run flat out. We could put a sleep in them, so we only check every hundred

38
03:32.290 --> 03:37.930
milliseconds, half a a second, a second, but then you have to decide what is the optimal time to wait.

39
03:39.730 --> 03:45.910
There is a nicer solution which is supported by C++, and that's something called a condition variable.

40
03:49.000 --> 03:55.990
When we have two or more threads which have critical sections which are protected by a mutex, a condition

41
03:55.990 --> 04:03.820
variable will use the mutex to coordinate the threads. In our example, the processing thread

42
04:03.850 --> 04:06.850
would tell the condition variable that it is waiting.

43
04:07.000 --> 04:08.110
And then it goes to sleep.

44
04:09.400 --> 04:16.300
The fetching thread would send a notification to the condition variable that it has finished, and then

45
04:16.300 --> 04:21.520
the condition variable will wake up the processing thread, which can then run and do its processing.

46
04:22.580 --> 04:23.770
So it would look something like this.

47
04:23.770 --> 04:31.690
We have the processing thread, which sends a "wait" message to the condition variable and then goes to sleep.

48
04:32.920 --> 04:39.550
When the fetching thread finishes, it will send a "notify" message to the condition variable and then

49
04:39.610 --> 04:43.900
the condition variable will send a "wake up!" message to the processing thread.

50
04:45.970 --> 04:54.040
The processing thread creates a unique lock instance to lock the mutex. It then calls wait() on the condition

51
04:54.130 --> 04:54.640
variable.

52
04:55.570 --> 04:58.900
The condition variable releases the lock and it will block the thread.

53
04:59.170 --> 05:04.150
So that is why we have to use a unique lock instance, because the condition variable needs to be able

54
05:04.150 --> 05:08.560
to call unlock(). The fetching thread creates a lock guard instance.

55
05:08.560 --> 05:12.760
We do not require anything more complicated. And that will give it a lock on the mutex.

56
05:14.510 --> 05:21.380
Then it fetches the data, it releases the lock and it notifies the condition variable. And then when the

57
05:21.380 --> 05:26.810
condition variable is notified, it will wake up the processing thread. The processing thread will get a lock

58
05:26.810 --> 05:27.500
on the mutex,

59
05:27.770 --> 05:29.960
It will resume execution and it will process the data.

60
05:29.960 --> 05:37.250
The way that the locks work means that the critical section is always protected.

61
05:38.300 --> 05:43.310
The critical section in the processing thread is locked until it sleeps.

62
05:43.310 --> 05:50.480
Then it is locked again when it wakes up and the critical section in the fetching thread is locked all the time

63
05:50.630 --> 05:55.880
it needs to be. So it may take a while to actually grasp how this all works, but it does work.

64
05:58.460 --> 06:04.490
So let's look at the C++ conditional variable. It is defined in the <condition_variable> header, there is

65
06:04.500 --> 06:09.800
a wait() function which takes an argument, which must be a unique lock on a standard mutex.

66
06:10.760 --> 06:17.210
This will unlock the argument and block the thread until the condition variable gets a notification.

67
06:18.230 --> 06:24.590
And there are also versions with time outs, wait_for() and wait_until(). If the notification is not

68
06:24.590 --> 06:28.670
received in time, then the mutex will be relocked.

69
06:29.270 --> 06:30.680
So you could run that in a loop.

70
06:33.280 --> 06:36.730
So these functions would be called by the processing thread.

71
06:38.010 --> 06:42.280
Then there are two functions which would be called by the fetching thread to send the notification.

72
06:42.730 --> 06:47.200
There is notify_one() which will send a notification to a single waiting thread.

73
06:48.610 --> 06:52.020
The thread which gets the notification is chosen by the system.

74
06:52.030 --> 06:54.310
You cannot decide which one it is going to be.

75
06:55.300 --> 07:01.120
And there is also notify_all() which will send a notification to every thread that is waiting on that condition

76
07:01.120 --> 07:01.570
variable.

77
07:05.250 --> 07:10.140
Let's have an example of this. We are going to have something very similar, a reading thread

78
07:10.140 --> 07:11.160
and a writing thread.

79
07:13.430 --> 07:18.800
The writing thread is going to modify a shared string and the reading thread is going to stop and wait

80
07:19.100 --> 07:25.700
until the string has been modified.
And then once the string is modified, the reader will start up again

81
07:26.060 --> 07:28.730
and it will have access to the new value of the shared string.

82
07:30.330 --> 07:36.450
We are going to use a condition variable to coordinate these two threads and we are also going to use

83
07:36.450 --> 07:38.910
a mutex to protect the shared data.

84
07:40.620 --> 07:43.310
So this is the code that's going to implement this.

85
07:43.590 --> 07:47.130
We have got the condition variable as a global.

86
07:48.720 --> 07:54.720
We have got the mutex, which is going to protect the critical sections and this is the shared data that is

87
07:54.720 --> 07:55.870
going to be modified.

88
07:57.420 --> 08:01.460
This is the reader thread, the one that is going to wait for the data to be modified.

89
08:02.130 --> 08:05.610
We create a unique look on the mutex.

90
08:07.260 --> 08:09.600
Then we call wait() on the condition variable.

91
08:09.930 --> 08:12.480
We pass the unique lock at its argument.

92
08:13.080 --> 08:18.360
So that is going to cause the thread to go to sleep. It will unlock the mutex and then the thread will sleep.

93
08:22.290 --> 08:29.140
In the modifying thread, we lock the mutex ourselves.
Then we modify the data.

94
08:29.170 --> 08:30.680
So this is our critical section.

95
08:31.020 --> 08:37.830
We put the lock guard in its own scope so that the lock will be released. And then we notify the condition

96
08:37.840 --> 08:38.280
variable.

97
08:39.360 --> 08:43.770
So that is going to send a signal to the condition variable, saying that the data has been modified.

98
08:46.410 --> 08:50.540
And then below that, we have a thread which will start up a thread.

99
08:50.670 --> 08:54.090
It also prints out the initial value of the data, just so we can see what is going on.

100
08:58.050 --> 08:58.690
So there we are.

101
09:00.810 --> 09:07.770
So we started off by printing out the initial value of the data in main().
Then the writer thread ran, so that

102
09:07.770 --> 09:09.290
modified the data.

103
09:10.560 --> 09:11.460
When it had modified it,

104
09:11.460 --> 09:12.720
it sent a notification.

105
09:13.050 --> 09:17.700
And then that woke up the reader thread, which printed out the value of the data.

106
09:28.500 --> 09:30.390
OK, so that's it for this video.

107
09:30.680 --> 09:36.240
We'll carry on talking about condition variables in the next video, but until then, keep coding!