WEBVTT

0
00:00.180 --> 00:00.750
Hello again.

1
00:00.960 --> 00:05.190
In this video, we are going to look at using condition variables with a predicate.

2
00:07.530 --> 00:15.600
In fact, there is a rather serious problem with the code that I showed you in the last video. You may

3
00:15.600 --> 00:20.000
have noticed that I started the write thread before the reader thread.

4
00:22.020 --> 00:25.620
It would have made more sense in the discussion to start the reader thread first.

5
00:26.970 --> 00:31.890
In fact, I was using some code that was meant to demonstrate the problem that I am talking about.

6
00:32.960 --> 00:39.800
So let's go ahead and do that now, actually. So I am going to put a sleep in here to make sure that

7
00:39.800 --> 00:44.170
the writer thread completes before the reading thread starts up.

8
00:44.990 --> 00:48.800
And let's change that to one second just to make sure that it does finish.

9
00:49.850 --> 00:51.380
And then when we run this...

10
00:54.810 --> 00:58.900
So we're waiting... Still waiting...

11
01:00.680 --> 01:02.290
We are going to wait forever,

12
01:02.310 --> 01:06.240
in fact. (Let's get out of that) So what is happening?

13
01:07.290 --> 01:09.120
So the writer thread, it runs first.

14
01:09.510 --> 01:12.780
It sends the notification to the condition variable.

15
01:14.830 --> 01:21.010
Then the writer thread will exit. Then the reader thread will run. It will call wait.

16
01:22.010 --> 01:27.830
And the problem is that this call will block indefinitely until the condition variable receives the

17
01:27.830 --> 01:31.280
notification, but the notification has already been received.

18
01:31.340 --> 01:32.630
So this waits for ever.

19
01:35.370 --> 01:41.880
So this is the problem. wait() will block until the notification is received. If the writing thread sends

20
01:41.880 --> 01:46.860
the notification before the reading thread calls wait(), then the reader will block further. The

21
01:46.860 --> 01:47.930
"wake up!" has been lost.

22
01:48.450 --> 01:51.300
So, in fact, this is a race condition.

23
01:53.600 --> 01:57.860
There is also a very obscure problem, so there are actually two problems with the code.

24
01:59.210 --> 02:05.270
It is possible for the waiting thread to be woken up, for the wait() call to return, even though

25
02:05.270 --> 02:09.140
the writing thread has not actually notified the condition variable.

26
02:10.480 --> 02:13.210
And this is known as a spurious wake up.

27
02:18.060 --> 02:23.490
This is actually due to a race condition in the condition variable itself.
So it is not just application programmers

28
02:23.490 --> 02:25.490
who have problems with data races!

29
02:26.790 --> 02:31.980
It is actually possible to implement the condition variable in such a way that it does not suffer from

30
02:32.070 --> 02:35.100
spurious wakeups, but that would involve too much overhead.

31
02:36.810 --> 02:40.620
Fortunately, there is a solution that C++ provides for this.

32
02:41.160 --> 02:45.030
And even better, it also solves the problem with the lost wakeup.

33
02:49.120 --> 02:55.360
The solution is that wait() will take a second argument, which is some kind of callable argument, it is

34
02:55.360 --> 02:56.560
a predicate function.

35
02:58.400 --> 03:05.150
The typical scenario is that this predicate function will check the value of a shared boolean. Initially

36
03:05.150 --> 03:13.280
this bool has the value false and then when the writing thread modifies the data, it sets it to true.

37
03:14.840 --> 03:21.710
The waiting thread will check this bool by calling this predicate, and it will only continue executing

38
03:22.040 --> 03:24.020
if the predicate returns true.

39
03:26.900 --> 03:36.230
So to use this, you need to first add a shared boolean flag to the code and then in the wait() call,

40
03:36.410 --> 03:39.800
we need to provide a callable object, which is going to check this flag.

41
03:40.640 --> 03:44.330
So here we have got our wait() call on the unique lock.

42
03:44.480 --> 03:50.240
And then as the second argument, we have the predicate function. And lambda functions are ideal for

43
03:50.240 --> 03:50.540
this.

44
03:54.780 --> 04:03.450
So here is some code that will do this. I have adapted the previous code to use the predicate.
Here is the

45
04:04.640 --> 04:07.430
boolean flag with the initial value false.

46
04:08.940 --> 04:15.970
Here is the call to wait() with the predicate as the second argument, which just checks the value of that flag.

47
04:17.100 --> 04:21.390
I have also added a print statement so we can see when the threads actually run.

48
04:25.120 --> 04:28.630
And then in the writing thread, we set the condition to true.

49
04:30.840 --> 04:36.810
Notice that we do this when the mutex is locked, so this will prevent a race condition on the boolean.

50
04:38.370 --> 04:43.620
As far as the reader is concerned, the mutex will be temporarily locked while this is checked.

51
04:44.250 --> 04:46.440
So there is no possibility of a data race.

52
04:48.440 --> 04:50.670
And the rest of the program is the same, I think...

53
04:52.400 --> 04:54.410
Yes. I have put in a sleep and...

54
04:55.850 --> 04:57.050
Okay, so let's try this.

55
04:59.840 --> 05:04.970
So there we are, we can see that the writing thread finishes before the reading thread starts, but

56
05:04.970 --> 05:10.730
the reading thread is able to return from the call to wait() and access the modified value of the shared

57
05:10.730 --> 05:11.170
data.

58
05:16.990 --> 05:24.040
So how does this prevent the lost wakeup scenario? When the wait() function is called by the reader,

59
05:24.820 --> 05:29.190
the wait() function will call the predicate internally. At that point,

60
05:29.230 --> 05:30.430
the mutex is still locked.

61
05:32.020 --> 05:38.950
If the predicate returns true, this means that the writing thread has already set the condition to

62
05:38.950 --> 05:39.320
true.

63
05:39.700 --> 05:42.100
So that means it must have already sent a notification.

64
05:43.570 --> 05:49.270
And in that case, the thread will resume execution with the mutex still locked, and it will carry on

65
05:49.270 --> 05:51.190
and do something with the shared data.

66
05:52.810 --> 05:57.370
If the predicate function returns false, that means the writer has not yet sent a notification.

67
05:57.880 --> 05:59.950
And then we have the normal scenario.

68
06:00.580 --> 06:05.650
So we release the lock and wait for a notification to be sent by the condition variable.

69
06:09.980 --> 06:16.940
For avoiding spurious wakeup. Remember, this is when the condition variable notifies the waiting

70
06:16.940 --> 06:17.250
thread.

71
06:17.270 --> 06:21.020
Even though the writing thread hasn't sent a notification.

72
06:23.330 --> 06:30.320
So when the waiting thread gets the notification, it will acquire a lock on the mutex. If the predicate

73
06:30.320 --> 06:32.840
returns true, then we know that the writing thread

74
06:32.990 --> 06:38.600
must have sent a notification because it has set the condition variable, which is all part of the same

75
06:38.600 --> 06:38.960
code.

76
06:39.440 --> 06:44.900
And in that case, it is safe to resume execution and we are still executing under the lock.

77
06:45.620 --> 06:52.100
If the predicate returns false, that means the writing threat has not set the boolean, so it cannot

78
06:52.100 --> 06:53.490
have sent a notification.

79
06:53.900 --> 06:55.670
So this is a false wake up.

80
06:56.480 --> 07:04.100
In that case, we release the lock and continue waiting. So you can see that this completely solves the

81
07:04.100 --> 07:06.710
problem with lost wakeups and spurious wake ups.

82
07:06.980 --> 07:11.540
So we should always use a predicate function when we are using a condition variable.

83
07:11.930 --> 07:14.420
So always add a second argument to wait().

84
07:16.900 --> 07:22.090
And finally, the real value from condition variables is when you have multiple threads waiting for

85
07:22.090 --> 07:28.530
the same event. As we said, there are two different member functions that can be called by the writing

86
07:28.570 --> 07:28.930
thread.

87
07:29.810 --> 07:35.350
They can call notify underscore all which will cause all the threads which are waiting on

88
07:35.350 --> 07:37.300
that condition variable to be woken up.

89
07:39.400 --> 07:45.070
The threads can wake up in any order, and this will cause all the reader threads to start processing

90
07:45.070 --> 07:45.700
their data.

91
07:46.840 --> 07:49.390
Alternatively, we can call notify underscore one.

92
07:49.810 --> 07:54.130
And in this case, only one of the threads which is waiting on that condition variable will be woken

93
07:54.130 --> 08:00.610
up. And it could be any one of the waiting threads.
The other threads which have called wait() will remain

94
08:00.610 --> 08:03.040
blocked until they eventually get their wake up call.

95
08:04.720 --> 08:10.020
And then once one thread has been notified, it cannot be notified again by the same condition variable.

96
08:10.600 --> 08:13.480
So we get a different thread processing the data each time.

97
08:16.590 --> 08:19.710
In this version, I am going to start up three reading threads.

98
08:23.950 --> 08:29.260
Each reading threat is going to print out its ID so we can see what is happening. The rest of the code

99
08:29.260 --> 08:29.860
is the same.

100
08:32.270 --> 08:42.050
In the modifying thread, we were originally calling notify_one, so let's call that first and then see what happens.

101
08:49.790 --> 08:55.670
OK, so all of the three reading threads have started running. Then the data has been written, but only

102
08:55.670 --> 09:00.150
one of the reading threads has actually been woken up and is processing the data.

103
09:00.650 --> 09:02.390
The other two are still waiting.

104
09:03.350 --> 09:08.870
And because we are only sending the notification once, the other two threads will not get a notification.

105
09:08.900 --> 09:10.160
So they're going to wait forever.

106
09:10.670 --> 09:15.410
So I will have to interrupt that.

107
09:15.410 --> 09:18.890
Now I am going to call notify_one() three times, once for each thread.

108
09:19.280 --> 09:23.690
So we should expect to see all the threads getting data and yes, there we are.

109
09:24.780 --> 09:27.960
And the three threads have been able to get their data.

110
09:32.810 --> 09:35.210
And then finally, I am going to call notify_all().

111
09:37.220 --> 09:42.260
So this should have the same effect, all three threads should run and be able to get their data.

112
09:42.680 --> 09:43.340
So there we are.

113
09:43.880 --> 09:48.110
Each time that notify_one() is called, one of the waiting threads is woken up.

114
09:49.070 --> 09:52.940
And when notify_all() is called, all the waiting threads are woken up.

115
09:54.140 --> 09:55.950
Okay, so that's it for this video.

116
09:56.240 --> 09:57.200
I'll see you next time.

117
09:57.230 --> 09:59.450
But meanwhile, keep coding!