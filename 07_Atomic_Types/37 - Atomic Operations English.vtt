WEBVTT

0
00:00.180 --> 00:00.700
Hello there!

1
00:00.900 --> 00:04.050
In this video, we are going to look at atomic operations.

2
00:07.570 --> 00:14.920
The atomic type supports a number of operations. We can store(),
which will atomically replace the object's

3
00:14.920 --> 00:19.940
value with its argument
and load() which will atomically return the object's value.

4
00:20.500 --> 00:25.020
These are equivalent to assigning to and assigning from an atomic variable.

5
00:25.270 --> 00:29.440
And in fact, you can write it using the normal equals sign.

6
00:31.880 --> 00:37.400
It is probably better, though, if you do use the names which are specific for atomic variables, as

7
00:37.400 --> 00:41.150
that will make it easier to see that the variable is atomic.

8
00:43.160 --> 00:49.730
There's also an exchange() member function,
which will replace the object's value and return the previous

9
00:49.730 --> 00:50.090
value.

10
00:51.860 --> 00:57.650
So this is a bit like doing a postfix increment where you increment and get the old value,
except it

11
00:57.650 --> 00:58.480
can be any value.

12
00:58.490 --> 01:00.530
It does not have to be old value plus one.

13
01:04.150 --> 01:09.520
Those member functions are common to all the atomic specializations. If we have pointers and integers, we

14
01:09.520 --> 01:13.720
can also do increment and decrement, += and -=.

15
01:16.770 --> 01:25.140
The integer specialisations also have a fetch_add() and a fetch_sub() which are atomic versions of postfix

16
01:25.380 --> 01:32.820
increment and decrement,
and there are some operators for doing bitwise logical operations atomically.

17
01:33.090 --> 01:38.250
So that is "and" with the single ampersand &, "or" with a single bar | and "exor" ^.

18
01:42.440 --> 01:44.820
There is another atomic type which comes in useful.

19
01:44.990 --> 01:48.920
This is atomic underscore flag, which is an atomic boolean type.

20
01:49.610 --> 01:56.000
It is guaranteed to be lock free and it has less overhead than the bool instantiation of the atomic

21
01:56.000 --> 01:56.540
template.

22
01:58.730 --> 02:04.620
It only supports three operations.
We can call clear(), which will set the Boolean to be false.

23
02:05.750 --> 02:09.300
We can call test_and_set() which will set the flag to be true.

24
02:10.220 --> 02:14.450
And the interesting bit is that it will return the previous value.

25
02:16.140 --> 02:23.010
So, again, this is rather like a postfix operation.
Like doing the postfix increment, we do the

26
02:23.010 --> 02:27.130
operation and we get the previous value. And we will see in a minute why that is useful.

27
02:28.470 --> 02:30.330
And there is also the assignment operator.

28
02:32.200 --> 02:37.450
Instances of atomic_flag must be initialized,
and the only possibility is ATOMIC_FLAG_INIT,

29
02:37.450 --> 02:39.850
which is equivalent to false.

30
02:41.230 --> 02:47.020
So the idea is that you create a shared atomic_flag variable, 
which is initially false, and then you

31
02:47.020 --> 02:49.180
have several threads which try to call test_and_set().

32
02:50.500 --> 02:53.950
So all these threads are trying to change the value of the flag.

33
02:56.220 --> 03:02.010
If the return value is true, then that means that the flag already had the value true,
so we have not

34
03:02.010 --> 03:02.570
changed it.

35
03:03.690 --> 03:12.090
If the returned value is false, then that means we have changed the value of the flag.
And we can use

36
03:12.090 --> 03:17.520
this property to impose a "happens before" ordering on the threats that are checking this flag.

37
03:18.150 --> 03:19.920
So this needs a bit of thinking about.

38
03:21.570 --> 03:25.560
Let's try and break it down. So the code would look like this.

39
03:27.060 --> 03:30.100
We create the flag value and initialize it to false.

40
03:30.840 --> 03:35.850
We have a thread function which calls test_and_set() on this flag variable.

41
03:37.650 --> 03:38.880
This is in a loop.

42
03:41.270 --> 03:48.140
The way this works is that if test_and_set() returns false,
then we are the thread that got to change

43
03:48.140 --> 03:50.370
the value and none of the other threads can do that.

44
03:50.840 --> 03:55.110
So if we execute the critical section,
we will be the only thread that can do that.

45
03:56.570 --> 04:00.920
While are we doing that, all the other threads are calling test_and_set() and getting the return value

46
04:00.920 --> 04:05.750
true, which indicates that they have not changed the value, so they continue looping.

47
04:06.710 --> 04:09.260
Eventually, we get to the end of our critical section.

48
04:09.260 --> 04:15.680
We clear the flag. We set it to false.
And then the next thread that calls test_and_set() will be able

49
04:15.680 --> 04:19.580
to change the value and then that thread can run its critical section.

50
04:21.820 --> 04:28.540
So let's go over this again. We initialize the flag to false, then each thread starts by calling

51
04:28.540 --> 04:34.920
test_and_set(). If this returns true, then it means some other thread is executing the critical section.

52
04:35.380 --> 04:37.140
So we loop and try again.

53
04:38.410 --> 04:44.380
If test_and_set() returns false, that means that we have set the flag and we can proceed into the

54
04:44.380 --> 04:45.210
critical section.

55
04:46.330 --> 04:49.870
And then when we exit the critical section, we set the flag to false.

56
04:50.230 --> 04:53.390
And that will allow another thread to enter the critical section.

57
04:53.920 --> 04:55.930
This is something that is known as a spin lock.

58
05:00.590 --> 05:02.330
So let's have a look at this.

59
05:05.990 --> 05:12.500
We have gone back to the example we had near the start 
where we were printing out strings in threads within

60
05:12.500 --> 05:12.950
loops.

61
05:15.030 --> 05:21.390
In our print function, instead of having a mutex or a lock guard or a unique lock,
we have this spinning

62
05:21.390 --> 05:22.200
test_and_set().

63
05:24.000 --> 05:25.640
So there is our atomic flag.

64
05:27.820 --> 05:33.070
Initialized to false. Then each thread is calling test_and_set() before the critical region.

65
05:36.090 --> 05:42.630
If this returns true, we know some other thread is executing this code.
And if it returns false then

66
05:42.630 --> 05:45.990
we know that we are the only one. And then we clear the flag at the end of the section.

67
05:46.680 --> 05:48.110
So let's see if this works.

68
05:50.170 --> 05:50.900
So there we are.

69
05:50.920 --> 05:55.390
That looks OK. Try it a few more times to make sure there are not any...

70
05:59.210 --> 06:00.340
No, we do not seem to be triggering it.

71
06:01.140 --> 06:05.520
And just to prove that this is doing something, let's comment these calls out.

72
06:11.840 --> 06:15.010
So it does not look quite so good.

73
06:16.640 --> 06:18.260
Let's see if we can get the race condition.

74
06:22.210 --> 06:29.890
There we are. So we have "abc" and "xyz" mixed up. So we get the data race when we remove the spin lock.

75
06:30.730 --> 06:35.500
And then if we put it back, it should work again.

76
06:44.740 --> 06:45.280
Okay.

77
06:47.970 --> 06:53.910
And then the headers are just normal ones. We use the <atomic> header for atomic flag as well as for

78
06:53.940 --> 06:54.810
the atomic type.

79
06:58.750 --> 07:00.700
What are the advantages of a spin lock?

80
07:02.210 --> 07:08.840
One advantage is that when a thread is spinning, it remains active.
It can execute immediately when

81
07:08.840 --> 07:15.890
the call to test_and_set() returns. With a mutex, the thread may have been put to sleep while it was waiting

82
07:16.280 --> 07:19.090
and the thread may need to be reloaded or even woken up.

83
07:20.930 --> 07:25.810
On the other hand, it is processor intensive. We have all these threads which are executing tight

84
07:25.820 --> 07:26.420
while loops.

85
07:26.750 --> 07:30.120
So all these processors are going to be running red hot!

86
07:31.070 --> 07:33.700
We should only do this for a very short period of time.

87
07:33.950 --> 07:37.250
So we need to keep the critical section very short when we are doing this.

88
07:38.210 --> 07:43.100
And also, if there is very low contention, if there are not many threads which are competing for the

89
07:43.100 --> 07:43.640
same spin lock.

90
07:43.640 --> 07:51.770
Because of this, spin locks tend to be used in operating systems and libraries rather than in application

91
07:51.770 --> 07:52.160
code.

92
07:54.890 --> 07:59.870
And one serious problem, if we have threads which are spinning and they interrupt each other, that

93
07:59.870 --> 08:01.260
can really hammer performance.

94
08:02.060 --> 08:04.670
So it does really need to be done by people who know what they are doing.

95
08:06.920 --> 08:11.210
One of the main applications of a spin lock is for implementing a mutex.

96
08:13.060 --> 08:19.120
Obviously, spin locks are not suitable for all mutexes if they have to wait a long time
or if there is

97
08:19.120 --> 08:24.760
lots of contention. But many operating systems implement what is called a hybrid mutex.

98
08:25.420 --> 08:29.050
So they spin briefly to see if they can get the lock straight away.

99
08:30.670 --> 08:34.690
And if they cannot get the lock, then they do the full mutex.

100
08:36.310 --> 08:40.190
Let's quickly go through the reasons why the spin lock is thread-safe.

101
08:40.450 --> 08:43.300
Again, it comes down to acquire-release semantics.

102
08:44.740 --> 08:50.890
When a thread reads the flag as clear, it acquires exclusive access to the critical section.

103
08:52.420 --> 08:58.810
When a thread sets the flag as clear, it will release exclusive access to the critical section.

104
08:59.200 --> 09:04.150
And it will also release the result of any modification which was made in the critical section.

105
09:05.770 --> 09:11.500
The next thread that reads the flag as clear and requires exclusive access will also acquire the

106
09:11.500 --> 09:13.150
result of those modifications.

107
09:14.590 --> 09:19.690
So when we have one thread that prints some output and then the next thread prints some output,

108
09:19.960 --> 09:26.440
the second thread will get the modified state of the output stream and it will not interleave its

109
09:26.440 --> 09:26.910
output.

110
09:28.690 --> 09:35.590
So these acquire and release semantics impose the "happens before" ordering on accesses to the variable

111
09:35.590 --> 09:36.670
or critical section.

112
09:37.040 --> 09:40.750
There is no data race and the program is always in a consistent state.

113
09:41.770 --> 09:43.540
Okay, so that's it for this video.

114
09:43.720 --> 09:44.620
I'll see you next time.

115
09:44.630 --> 09:46.630
But meanwhile, keep coding!