WEBVTT

0
00:00.150 --> 00:05.130
Hello there. In this video, we are going to briefly look at the structure of threaded programs and then

1
00:05.130 --> 00:07.830
find out how to launch a thread in C++.

2
00:10.480 --> 00:18.190
With a single threaded program, which is what you normally get, there is a main function and there is

3
00:18.190 --> 00:21.340
a single thread of control known as the main thread.

4
00:22.030 --> 00:24.500
So the program will call the main() function.

5
00:25.330 --> 00:31.210
This thread will continue executing. The main function could go off and call some other functions.

6
00:31.960 --> 00:37.210
And eventually the main function returns, the main thread ends and the program terminates.

7
00:42.470 --> 00:48.680
When we have a multithreaded program, we still have the main function and the main thread. But we

8
00:48.680 --> 00:56.510
can start up other threads. Each thread starts executing some function that we tell it to execute.

9
00:57.080 --> 01:02.420
So in this case, we're running a function called task() and we are starting up a new thread to run this.

10
01:04.010 --> 01:08.070
By default, the main thread is going to continue executing while

11
01:08.230 --> 01:10.760
this thread executes at the same time as well.

12
01:11.330 --> 01:16.700
We can tell the main threat to stop and wait until the thread finishes, if that is what we need to do.

13
01:18.650 --> 01:25.580
This task() is like any other function. It can call functions itself and it can also start threads itself.

14
01:25.940 --> 01:28.610
And the main function can start more threads as well.

15
01:32.370 --> 01:38.070
So when the thread starts executing, the entry point function that we associate with that thread is

16
01:38.070 --> 01:42.210
called, and when that function returns, that thread will end.

17
01:43.470 --> 01:48.510
And the main thread does not wait for other threads unless we explicitly tell it to.

18
01:52.420 --> 01:59.980
In C++, there's a close coupling between the thread objects and the threads provided by the operating

19
01:59.980 --> 02:00.460
system.

20
02:01.120 --> 02:06.790
There is a class in the standard library called thread, which manages this, and it is defined in the

21
02:06.790 --> 02:08.560
header, which is also called thread.

22
02:10.180 --> 02:16.730
A thread object manages a kernel thread, so it is a resource management class.

23
02:17.230 --> 02:21.700
So like most classes which manage resources, it cannot be copied, but it can be moved.

24
02:22.090 --> 02:23.310
It is the same as with files.

25
02:23.320 --> 02:29.260
If you have a class which manages a file handle, then you cannot copy that class because it would be

26
02:29.260 --> 02:32.920
chaos if two different classes think they both own the same file handle.

27
02:35.080 --> 02:41.740
The constructor for the thread takes a callable object as its first argument, so that could be a function

28
02:41.740 --> 02:42.280
pointer.

29
02:42.880 --> 02:44.500
It could be a lambda expression.

30
02:44.530 --> 02:47.710
It could be a functor with an overloaded operator.

31
02:50.040 --> 02:51.900
It could be a member function pointer.

32
02:52.170 --> 02:54.820
It could be an object created by bind() and so on.

33
02:55.470 --> 02:57.330
And this is the entry point to the thread.

34
02:57.570 --> 03:01.380
So this is the code that the thread is going to start executing when it runs.

35
03:03.820 --> 03:09.670
The function, the callable object that we pass to the thread must not be overloaded.

36
03:10.990 --> 03:15.160
We can give it arguments and it can take these by value, by reference or by move.

37
03:16.730 --> 03:19.610
If it returns a value, then that [value] is going to be ignored.

38
03:19.970 --> 03:23.030
We will find out later on how to get a value from a thread.

39
03:27.150 --> 03:31.890
Once we create our thread object, it will start running immediately and calling the function with the

40
03:31.890 --> 03:35.730
arguments we give it. You do not have to tell it to run, like you do in Java.

41
03:36.150 --> 03:38.400
And there is only one thread class in C++.

42
03:40.710 --> 03:45.840
If you want the parent - the main thread or some other thread which starts a thread - if we want that

43
03:45.840 --> 03:50.510
to stop and wait for the thread, we call the join() member function on the thread.

44
03:52.050 --> 03:58.470
So if we're in main() and we create a thread object, we can call it t, and if we call t.join(),

45
03:59.010 --> 04:03.720
then the main function will stop and wait until the thread has terminated.

46
04:04.470 --> 04:11.790
If we do not do that, the parent will carry on executing and it is possible that the main thread and

47
04:11.790 --> 04:13.620
therefore the program will terminate

48
04:13.930 --> 04:16.610
while the thread is still running and that's not good.

49
04:18.710 --> 04:21.530
OK, so I'm going to write a threaded program now.

50
04:23.710 --> 04:26.580
I'm including the thread header.

51
04:28.240 --> 04:29.710
I'm going to write my function.

52
04:31.870 --> 04:33.190
So this is very simple.

53
04:33.340 --> 04:35.620
It's basically the thread version of "Hello World".

54
04:36.620 --> 04:43.440
So we are just going to print out "Hello Thread". We have a function that takes no arguments and returns nothing.

55
04:43.660 --> 04:44.770
Keep it nice and simple.

56
04:45.880 --> 04:49.990
And then in the main function I will create a thread instance.

57
04:53.170 --> 05:00.100
And then I am going to initialize it with the name of this callable object, which is a function pointer

58
05:00.100 --> 05:01.300
to my hello function.

59
05:04.420 --> 05:08.320
And let's see what happens if I run, just run that as it is.

60
05:11.840 --> 05:12.290
Oops!

61
05:12.320 --> 05:16.060
Now, it has printed out "Hello thread".

62
05:16.100 --> 05:17.810
So it has called this thread function.

63
05:18.500 --> 05:22.130
The problem is that we did not stop and wait for the thread to complete.

64
05:22.640 --> 05:26.870
So the main thread terminated before this one had finished.

65
05:28.560 --> 05:29.870
So let's fix this.

66
05:32.520 --> 05:33.940
So we put a join() call.

67
05:33.960 --> 05:41.100
So we call the join() member function of our thread object. Let's see if it works properly this time.

68
05:42.270 --> 05:43.090
Yes, that's better.

69
05:46.390 --> 05:51.860
So you should always call join() when you create a thread.
You can do some work in between here so

70
05:51.860 --> 05:52.900
we could, for example...

71
05:57.850 --> 05:58.780
"Doing some work..."

72
06:12.020 --> 06:16.880
And that's interesting. Because they are both running at the same time, the output is actually mixed

73
06:16.880 --> 06:17.140
up.

74
06:17.990 --> 06:20.700
So we have got to "doing some work". Then

75
06:20.750 --> 06:25.610
We have got the "Hello Thread" and then we have got the new line from this, after the "Hello Thread" printed.

76
06:26.420 --> 06:27.770
So that is something that is worth remembering.

77
06:28.890 --> 06:33.420
When you have threads running at the same time, their actions can "interleave".

78
06:34.800 --> 06:37.260
And we will have lots more to say about this later on.

79
06:40.180 --> 06:46.660
Let's take a look now at a function which takes an argument. 
So I've got this hello function, which is

80
06:46.960 --> 06:49.600
passed the string instead of doing it itself.

81
06:50.710 --> 06:55.210
We'll have to give this a different name because we cannot have overloaded functions.

82
06:55.210 --> 06:59.950
So I will call this hello2, then we put hello2...

83
07:00.040 --> 07:01.490
(Let's just comment this out for now,

84
07:01.570 --> 07:09.010
get rid of this) and see what happens if we try and compile that.

85
07:10.490 --> 07:15.890
It's not going to work. No.
"no matching function", because we need to give it an argument.

86
07:16.850 --> 07:17.960
So let's say...

87
07:31.880 --> 07:35.390
So there we go, let's try running that.
There we are, "hello thread".

88
07:37.020 --> 07:38.310
I have actually got two new lines!

89
07:44.080 --> 07:45.040
Let's try it again...

90
07:46.120 --> 07:46.560
There we are.

91
07:49.410 --> 07:57.300
Okay. We can also pass the arguments by reference as well as by value,
so in this case, we are creating

92
07:57.300 --> 07:59.270
a temporary string and passing that value.

93
08:00.420 --> 08:07.410
But if you want to have a function which takes an argument by reference, so let's say...

94
08:12.950 --> 08:16.570
So we are going to the string then we are going to change its value...

95
08:21.760 --> 08:27.740
And we need hello3, we need to give it an argument, so let's have... 

96
08:33.170 --> 08:37.190
string "abc". We need to include the string header for that to compile.

97
08:47.020 --> 08:48.040
Let's clear these out...

98
08:52.060 --> 08:54.070
So we call this hello3 function.

99
08:56.830 --> 08:59.100
If we just give it, s, it is not going to work.

100
09:02.560 --> 09:05.470
Because it needs a reference and we're just passing it by value.

101
09:06.810 --> 09:13.990
What we can do is put this std::ref() around it and that will convert it to a reference.

102
09:14.390 --> 09:15.810
This is actually a template function.

103
09:16.870 --> 09:18.250
So it is basically a kind of cast.

104
09:24.010 --> 09:29.440
OK, and for bonus points, let's prove that we have actually changed the string!

105
09:42.140 --> 09:49.370
Yes, so there we are. The string is now "xyz". So it was "abc", we passed it to this function that takes the

106
09:49.370 --> 09:50.300
string by reference.

107
09:50.510 --> 09:57.650
It changed the value to "xyz", and then in main() this string has now been changed to "xyz".

108
10:00.880 --> 10:02.950
We can also do pass by move.

109
10:05.990 --> 10:13.070
So let's put a function in which is going to take the ownership. We could put the double refs && in here,

110
10:13.280 --> 10:17.510
but it is not actually necessary because we're going to use std::move().

111
10:19.140 --> 10:21.320
Let's put the double refs in here for the time being.

112
10:22.490 --> 10:30.080
So instead of using std::ref() to cast it to an lvalue reference, we are going to use std::move() to cast it to

113
10:30.080 --> 10:33.950
an rvalue reference. (And change the function...)

114
10:38.830 --> 10:39.160
Let's see what that does.

115
10:44.180 --> 10:53.240
So we've got the ownership of "abc", so this function has been called.
The string in here is empty because

116
10:53.240 --> 10:54.860
the data has been moved out of it.

117
10:56.660 --> 11:01.300
So when we put std::move() around the argument,
that gets moved into the thread function.

118
11:01.640 --> 11:08.510
So the data gets transferred from this string instance here to the local string instance inside func().

119
11:10.100 --> 11:13.360
And then when we examine s, there is nothing in it.

120
11:13.670 --> 11:18.460
This is actually not sound because the data has been moved out of it.

121
11:18.470 --> 11:20.300
So it is not actually in a valid state.

122
11:20.900 --> 11:24.340
It is safe to assign to this variable, but not to read from it.

123
11:24.650 --> 11:26.630
So we are a bit naughty, really!

124
11:29.220 --> 11:32.390
Anyway, we proved that the data has been moved from the string.

125
11:34.690 --> 11:38.940
We can also have member functions as the thread function.

126
11:40.460 --> 11:44.190
So I have got this class here which has a member function called hello().

127
11:44.240 --> 11:51.040
So the class greeter and the hello member function.

128
11:51.080 --> 11:52.190
So we want to call that.

129
11:55.120 --> 11:57.190
So let's just comment this out for a minute.

130
12:03.360 --> 12:06.540
So we need to create an instance of this class....

131
12:12.010 --> 12:14.200
Then we create our thread instance....

132
12:17.730 --> 12:19.320
And it's going to be greet...

133
12:25.930 --> 12:32.050
And if you remember when we call a member function, it gets a copy of the "this" pointer, which is

134
12:32.050 --> 12:33.700
the object that it has been called on.

135
12:34.240 --> 12:35.930
So we need to provide that as well.

136
12:35.950 --> 12:41.320
So we need to provide the address of the object that we want it to be called on.

137
12:42.800 --> 12:45.520
(And let's use the correct type of bracket!)

138
12:46.480 --> 12:49.810
Okay.
Then we need to join on that...

139
12:52.840 --> 12:54.240
And let's try that out.

140
12:58.410 --> 12:59.420
I've got something wrong!

141
13:01.690 --> 13:02.000
OK.

142
13:02.200 --> 13:08.710
It should be an ampersand in front of the name of the member function,
so ampersand, class name, double colon,

143
13:09.310 --> 13:13.780
function name to get the member function pointer and then the address of the object.

144
13:14.230 --> 13:14.830
So there we are.

145
13:14.980 --> 13:15.370
"Hello,

146
13:15.610 --> 13:17.960
member function". I finally got it to work!

147
13:19.180 --> 13:21.640
OK, so that's probably enough for one video.

148
13:23.310 --> 13:28.640
The main things to remember are that we have this standard library thread class.

149
13:28.650 --> 13:30.260
We use #include <thread> to work with it.

150
13:30.690 --> 13:35.280
I don't think you need any extra libraries these days, if you have a modern compiler.

151
13:36.960 --> 13:42.240
To start a thread, you create an instance of the thread class, the first argument is the function or

152
13:42.240 --> 13:46.950
some other callable object,
and that will get called when the thread starts up.

153
13:47.670 --> 13:52.700
The following arguments to the thread constructor will get forwarded to that function.

154
13:53.340 --> 13:56.760
You can use references or move as you wish.

155
13:59.270 --> 14:06.770
The thread that you start up and the thread that you are creating it in will run at the same time and

156
14:06.770 --> 14:12.180
you need to call join() on the new thread, to make the existing threat stop and wait for it.

157
14:12.770 --> 14:16.390
And if you do not do that, it could finish before the new thread does.

158
14:18.150 --> 14:19.700
OK, then, I'll see you next time.