WEBVTT

0
00:00.150 --> 00:05.370
Hello again. In this video, we are going to look at managing a thread. So we've learned how to launch

1
00:05.370 --> 00:05.790
a thread.

2
00:06.000 --> 00:07.860
Now we are going to learn how to manage it.

3
00:11.050 --> 00:17.110
So the basic idea is that we have the main thread or possibly some other parent thread which will create a

4
00:17.110 --> 00:25.090
thread object, and that will cause a child execution thread to run, and that will call some sort of function

5
00:25.180 --> 00:27.250
that we give it, which will execute in that thread.

6
00:28.240 --> 00:33.670
We said that we should always call join() to make sure that the parent will stop and wait for the child

7
00:33.670 --> 00:34.300
to complete.

8
00:35.530 --> 00:38.700
There is actually an alternative to that, which is to call detach().

9
00:39.670 --> 00:43.180
In that case, the parent carries on running and ignores the child.

10
00:43.930 --> 00:47.470
So they both run in their own little universes, if you like.

11
00:49.070 --> 00:54.840
The detached thread will carry on running until it has completed or the program terminates, and the parent thread

12
00:54.860 --> 01:01.310
will also continue executing. If you have done any Unix system programming,

13
01:01.520 --> 01:04.520
this is similar to forking a process and running the child as a daemon.

14
01:04.520 --> 01:08.480
And I think the Windows equivalent is called a service.

15
01:10.470 --> 01:16.200
As far as the thread object is concerned, it will have some resources in it which are there in case

16
01:16.200 --> 01:17.100
it needs to join.

17
01:18.230 --> 01:23.430
When you call detach() on the thread, these resources are no longer needed and they are released immediately.

18
01:25.500 --> 01:30.750
If the detached thread is still running when the program ends, the destructor is called for the thread

19
01:30.750 --> 01:34.670
object and that'll terminate the thread. So everything gets handled properly.

20
01:38.750 --> 01:40.470
You can visualize it like this.

21
01:40.520 --> 01:45.950
This is a kind of event diagram, so in the case where we call join(), the parent thread will be

22
01:45.950 --> 01:46.400
running.

23
01:47.090 --> 01:53.270
It will create a child thread, the child thread will go off and execute. The parent thread will stop

24
01:54.140 --> 02:00.620
after it calls join() and wait until the child is completed, and then the parent will start executing again.

25
02:02.560 --> 02:08.350
In the detach() case, the parent thread will run, it will create a child thread, but the parent

26
02:08.350 --> 02:10.070
will continue running as well.

27
02:11.110 --> 02:14.100
So both these threads will be running at the same time.

28
02:18.670 --> 02:22.180
We also said that when the child thread throws an exception,

29
02:22.220 --> 02:23.890
it has to be dealt with by that thread.

30
02:24.940 --> 02:27.460
What happens when the parent throws an exception?

31
02:28.870 --> 02:34.390
As you would expect, the destructors are called for every object in scope, and that includes any thread

32
02:34.390 --> 02:34.950
objects.

33
02:35.860 --> 02:39.010
The destructor for std::thread will carry out a check.

34
02:39.340 --> 02:43.360
It will check whether join() or detach() have been called on that object.

35
02:44.590 --> 02:49.570
And if they have, it will go ahead and terminated the execution thread.

36
02:50.590 --> 02:56.560
If neither of those has been called, the destructor will give up, it will call std::terminate() and that will

37
02:56.560 --> 03:00.940
probably cause the program to terminate immediately, which is not what we want.

38
03:01.870 --> 03:06.700
So we must make sure that we call either join() or detach() before the thread gets destroyed.

39
03:08.480 --> 03:15.020
So this is the kind of code that can cause this problem. We create a thread which is running, we have

40
03:15.020 --> 03:19.130
some code that can throw an exception, and then we do a join() on the thread.

41
03:21.380 --> 03:28.010
The problem is, if this code throws an exception, the destructor for the thread object will be called

42
03:28.790 --> 03:31.880
and then the function will exit the scope [immediately].

43
03:34.590 --> 03:39.630
So join() never gets called. So when the destructor runs, it will see that join() has not been called and

44
03:39.630 --> 03:40.580
it will call terminate().

45
03:41.160 --> 03:43.590
So this is going to abruptly end the program.

46
03:47.960 --> 03:52.100
The obvious way to address this is to add a try-catch block.

47
03:53.130 --> 03:59.160
We will put the code that might throw inside a try block and then we have a catch block, which

48
03:59.160 --> 04:00.060
is going to call join().

49
04:02.080 --> 04:08.560
So if this code does throw, then the program will jump into the catch block, it will call join(),

50
04:09.220 --> 04:10.420
and the destructor will be called.

51
04:10.600 --> 04:16.290
So that will be OK because the destructor will see that the object has already been joined.

52
04:17.890 --> 04:22.900
If this code does not throw, then the program will jump over the catch block and it will execute

53
04:23.230 --> 04:27.580
this join() statement here, and then the thread will be destroyed.

54
04:29.060 --> 04:35.720
So this is all very good and safe, but it's rather verbose. Five lines of code which don't actually

55
04:35.720 --> 04:38.770
provide any functionality and we have to call join() twice.

56
04:39.260 --> 04:40.730
So it is certainly not elegant.

57
04:44.780 --> 04:52.160
If you have done my Advanced Modern C++ course, you may remember something called RAII. This is an idiom

58
04:52.160 --> 04:55.040
for writing classes that manage resources.

59
04:55.460 --> 05:02.120
So the idea is that you have the resource as a private data member of the class, you acquire the resource

60
05:02.120 --> 05:08.030
in the constructor and you release it in the destructor, and you make whatever changes are needed for

61
05:08.030 --> 05:13.240
the copy and move operators to handle ownership changes correctly.

62
05:15.310 --> 05:21.040
The great advantage of this is if you have an object of the class on the stack, it will be destroyed

63
05:21.070 --> 05:24.910
whenever the object goes out of scope or when an exception is thrown.

64
05:25.570 --> 05:31.180
So regardless of how many return paths there are in your code or how many exceptions get thrown and where,

65
05:31.510 --> 05:36.460
including ones that you do not know about when you are writing the code, whatever happens in that regard,

66
05:36.760 --> 05:40.420
the destructor will always be called and the resource would always be released.

67
05:41.020 --> 05:45.040
So RAII gives you a very strong protection against resource leaks.

68
05:46.420 --> 05:47.900
In this case, it is slightly different.

69
05:48.190 --> 05:50.140
We are not worried about resource leaks.

70
05:50.500 --> 05:54.070
We are worried about threads not being joined before they are destroyed.

71
05:55.420 --> 05:57.790
But we can solve this as well with RAII.

72
05:58.300 --> 06:04.300
So we have a thread object as a member of the class and then in the destructor of the class,

73
06:04.780 --> 06:06.670
we call join() on that object.

74
06:08.230 --> 06:13.960
We need to be a bit careful here because a thread can only be joined or detached once. If you call join()

75
06:13.960 --> 06:17.970
twice or call join() and detach(), then that is not going to work.

76
06:19.580 --> 06:24.920
Fortunately, there is another member function called joinable(), and we can call that to check

77
06:24.920 --> 06:26.360
whether it is safe to call join().

78
06:28.730 --> 06:33.240
If join() or detach() have already been called on that object, then this will return false.

79
06:33.260 --> 06:35.360
So we know that we don't want to call join() again.

80
06:37.170 --> 06:42.800
Also, if the thread object does not actually have any associated execution thread - it could have been

81
06:42.800 --> 06:46.320
a default constructed object - then it will return false as well.

82
06:46.880 --> 06:50.300
We do not want to call join() because there is no execution thread to join to.

83
06:52.520 --> 06:54.440
And otherwise, it is going to return true.

84
06:54.470 --> 06:56.270
So in that case, we do need to call join().

85
06:59.650 --> 07:03.170
So this is what the basic part of the class could look like.

86
07:03.520 --> 07:09.760
So we have a thread object, which is a private member of this class, and we have the destructor.

87
07:10.960 --> 07:12.790
So we check if it is joinable.

88
07:15.220 --> 07:20.670
And if it is joinable, then we call join(). And obviously, if it's not joinable, we do nothing.

89
07:23.220 --> 07:30.570
We need to get the thread objects into this class so we are going to write a constructor. Now, thread is a move only

90
07:30.570 --> 07:37.070
object, so this will have to be a move constructor, and we will have to move the argument into our own

91
07:37.080 --> 07:37.590
variable.

92
07:39.090 --> 07:48.560
So it will look something like this. thread_guard, the constructor, is going to take a thread by move.

93
07:49.260 --> 07:50.850
So we need the double ampersands.

94
07:51.840 --> 07:56.030
And then we get the argument, which is going to be passed as an lvalue.

95
07:56.250 --> 08:00.210
So we need to cast that back to a rvalue by calling std::move().

96
08:01.950 --> 08:06.530
We also make the constructor explicit. It is probably not really necessary here, but it is a good idea.

97
08:06.810 --> 08:09.600
It will avoid any surprising conversions.

98
08:11.950 --> 08:19.420
(Let's put some comments in here... so join thread if necessary.

99
08:25.670 --> 08:30.050
Constructor (thread is move-only)

100
08:34.800 --> 08:44.280
I should say std::thread. So that's the destructor call. Quite often with resource management classes,

101
08:44.290 --> 08:46.030
we do not want to be able to copy them.

102
08:46.460 --> 08:48.630
For example, fstreams are not copyable.

103
08:50.600 --> 08:54.250
In this case, we're writing something which is meant to behave like std::thread.

104
08:55.010 --> 08:56.260
That's not copyable.

105
08:56.270 --> 09:00.000
So this should be not copyable as well.

106
09:00.020 --> 09:04.820
So we're going to delete the copy constructor and copy assignment operator.

107
09:12.890 --> 09:18.710
However, it might be useful to be able to move these - the std::thread object is movable.

108
09:19.010 --> 09:20.920
So let's add some move operators.

109
09:21.930 --> 09:28.940
We wil not get any generated by default because we've already put a destructor in. When there is is a destructor,

110
09:28.940 --> 09:31.010
The compiler will not generate default

111
09:31.030 --> 09:31.790
move operators.

112
09:32.910 --> 09:34.170
But we can provide our own.

113
09:40.670 --> 09:47.930
We can use the defaults, those will be good enough. Notice of course that the move constructor, does not

114
09:47.930 --> 09:54.080
take a const argument, because it changes the argument. And usually we make these operators noexcept.

115
09:55.730 --> 09:57.200
Then the assignment operator.

116
10:01.810 --> 10:02.350
Okay.

117
10:05.200 --> 10:08.540
Then to use this class, we need to create a

118
10:11.420 --> 10:12.320
thread instance.

119
10:18.500 --> 10:25.990
It does not really matter what it does, this is just a demonstration. Then we create an instance of our thread_guard

120
10:26.000 --> 10:26.420
class.

121
10:29.240 --> 10:34.790
Then we move the thread into it... std::move()

122
10:38.780 --> 10:42.980
And then when the object goes out of scope, the destructor for that will be called.

123
10:43.850 --> 10:46.600
So the destructor calls are in reverse order.

124
10:46.880 --> 10:48.830
The thread_guard destructor is called first.

125
10:49.410 --> 10:53.150
Then once that is run, the destructor for the threat will be called.

126
10:55.410 --> 11:00.590
So first of all, the thread will be joined, if applicable, then the thread object will be destroyed

127
11:00.600 --> 11:03.670
and that will terminate the underlying execution threaD.

128
11:03.930 --> 11:04.920
So it all gets handled.

129
11:06.710 --> 11:13.480
And in your code, which actually does the work, it just has one extra line of code instead of all that

130
11:13.490 --> 11:15.240
try-catch boilerplate.

131
11:16.190 --> 11:18.250
And also this object is reusable.

132
11:18.590 --> 11:22.970
You can use it anywhere where you want to have a thread and you might have to deal with exceptions or

133
11:23.240 --> 11:24.330
multiple return paths.

134
11:31.970 --> 11:40.070
C++20 has an additional class called jthread in the standard library, and the destructor for jthread

135
11:40.070 --> 11:42.020
will actually do all that for us.

136
11:42.030 --> 11:46.710
So it will check whether the thread is joinable and it will automatically call it, if it is needed.

137
11:48.410 --> 11:51.650
So we can rewrite our program without putting any extra code in at all.

138
11:52.030 --> 11:56.510
I can just create an instance of std::jthread and off it goes.

139
11:58.740 --> 12:06.510
And finally, stopping threads. In some languages, there are facilities for interrupting or stopping

140
12:06.510 --> 12:12.570
threads, or killing or cancelling or terminating or various other terms that sound like they were written

141
12:12.570 --> 12:15.320
by a gangster! C++

142
12:15.330 --> 12:16.940
does not directly support this.

143
12:17.460 --> 12:22.200
The book by Williams has a very good interruptible thread class.

144
12:22.200 --> 12:23.760
So you can use that.

145
12:24.300 --> 12:30.210
If you want to be "uncivilized", you can go to the operating system. And also things like the pthreads

146
12:30.210 --> 12:35.660
library and boost have facilities for stopping a thread "with extreme prejudice".

147
12:36.960 --> 12:40.620
Generally, it is not a good idea to stop a thread dead in its tracks.

148
12:40.950 --> 12:46.370
The execution thread will get stopped, but the thread object will still be alive.

149
12:46.380 --> 12:52.500
So you have memory leaks. And you may very well get other problems, such as deadlocks, which we are

150
12:52.500 --> 12:54.150
going to talk about later on in the course.

151
12:57.200 --> 13:04.250
jthread in C++20 also supports cooperative interruption. So you can politely ask it whether it wouldn't

152
13:04.250 --> 13:08.990
mind stopping at some point. There is the request underscore stop member function.

153
13:09.710 --> 13:16.190
And if you call that, the thread will terminate, but it does not have to. It can wait until it is ready or it

154
13:16.190 --> 13:18.270
can even not terminate at all.

155
13:21.100 --> 13:22.720
Okay, so that's it for this video.

156
13:22.780 --> 13:25.390
I'll see you next time, but meanwhile, keep coding.