WEBVTT

0
00:00.180 --> 00:00.690
Hello again!

1
00:00.930 --> 00:06.930
In this video, we are going to talk about how to choose a thread object,
amongst some other odds and ends

2
00:06.930 --> 00:08.580
to finish off the section.

3
00:10.500 --> 00:17.010
In the async function lecture, I did not cover how to deal with exceptions, so let's look at that now.

4
00:20.230 --> 00:27.190
If you remember back to when we were looking at promises and futures,
we had a situation where a thread

5
00:27.670 --> 00:32.110
threw an exception and it was passed through a promise, to a future object.

6
00:32.440 --> 00:36.330
And then when we called get() on that future, we put a try-catch block around it.

7
00:36.940 --> 00:38.520
So we're going to do the same thing here.

8
00:38.890 --> 00:45.730
We get a future when we call async() and then when we call get() on that future,
we are going to put it

9
00:45.760 --> 00:47.110
inside a try block.

10
00:49.290 --> 00:56.700
And if the future contains a value, then we will get the value. If it contains an exception, then

11
00:56.700 --> 01:02.000
it is going to throw the exception when we call get()
and then the catch block will come into play.

12
01:04.880 --> 01:11.990
I have got a function which will return a value, so let's try that first without the exception,
just

13
01:11.990 --> 01:12.980
to make sure that it works.

14
01:15.140 --> 01:16.340
So our future is calling

15
01:16.340 --> 01:16.790
get()...

16
01:18.980 --> 01:25.460
And in this case, there was no exception,
so we got a value and we did not go into the catch block.

17
01:25.690 --> 01:28.760
Now let's uncomment the exception...

18
01:32.210 --> 01:34.060
and try it again.

19
01:36.100 --> 01:37.720
So we are calling get()...

20
01:40.880 --> 01:41.820
And they we are.

21
01:42.080 --> 01:48.620
So when we called get(), an exception was thrown
and this was caught and we went into the catch block.

22
01:52.880 --> 01:54.650
OK, so that is the main function...

23
01:59.140 --> 02:01.480
We just have the usual include files.

24
02:03.850 --> 02:08.650
So we now have three different ways in which we can create a thread.
We can call the async() function,

25
02:09.100 --> 02:14.280
we can create a packaged task object, or we can create a standard thread object.

26
02:14.860 --> 02:19.590
So what are the relative strengths and weaknesses of these.
And when should we use them?

27
02:22.470 --> 02:25.110
async() is the simplest way to start a task.

28
02:26.220 --> 02:32.090
We can use it and get the return value from a task function.
If the task function throws an exception,

29
02:32.100 --> 02:33.080
we can get that as well.

30
02:34.910 --> 02:39.410
We can choose whether we want to run the task synchronously or asynchronously.

31
02:41.870 --> 02:47.330
If we need to do something that might block, but we need to remain responsive,
then we can call

32
02:47.330 --> 02:50.330
async() to run the work in the background.

33
02:53.250 --> 02:59.100
async() provides a higher level of abstraction than the standard thread class.
The library will manage the

34
02:59.120 --> 03:01.440
threads for us, so we do not need to start

35
03:01.440 --> 03:02.550
threads and join them.

36
03:04.570 --> 03:11.680
We can get threads to communicate using messages instead of shared data,
so we do not need to worry

37
03:11.680 --> 03:14.050
about mutexes and atomic variables.

38
03:17.660 --> 03:22.970
The main disadvantage of async() is that there is no way to have a thread which is detached.

39
03:25.320 --> 03:32.370
The reason for this is the way that the future destructor is designed.
The future has some shared

40
03:32.370 --> 03:36.120
state which is used for passing results and exceptions and so on.

41
03:37.620 --> 03:43.460
When we have a thread that is launched with the launch_async policy, then the destructor will block until the

42
03:43.470 --> 03:44.400
thread has completed.

43
03:45.750 --> 03:49.000
So that means the future will always wait for the thread.

44
03:51.960 --> 03:58.740
Packaged task is the best choice if we want to represent a task as an object.
For example, if we are creating

45
03:58.740 --> 03:59.970
a container of tasks.

46
04:01.400 --> 04:06.680
A packaged task is an object so we can move it onto a particular thread and make it execute on that thread,

47
04:07.160 --> 04:10.180
which we cannot do with async() because async() is not an object.

48
04:12.060 --> 04:15.120
It has less overhead than async() and is more flexible.

49
04:19.060 --> 04:25.430
And the standard thread class is the most flexible of all.
We can use it to access the underlying software

50
04:25.430 --> 04:30.520
thread so we can use features which are provided by the operating system, but not supported by standard

51
04:30.520 --> 04:31.280
C++.

52
04:32.020 --> 04:34.720
And you can also detach standard thread if you want to.

53
04:38.280 --> 04:42.450
My recommendations are that you would normally use async() for starting a thread.

54
04:44.080 --> 04:48.790
Bjarne Stroustrup says that async() is the equivalent of range for loops.

55
04:50.070 --> 04:56.130
If you want to iterate over all the elements in a container once,
then you would use a range for

56
04:56.130 --> 04:56.460
loop.

57
04:57.930 --> 05:03.900
If you want something a bit more specific, if you only want to iterate over some of the elements or

58
05:03.900 --> 05:09.690
you want to add or remove elements,
then you would use a lower level loop and write some more code.

59
05:10.530 --> 05:15.990
And similarly, if you want to do something more specialized, which isn't supported by async(), then

60
05:15.990 --> 05:18.960
you would use the standard thread class and write some extra code.

61
05:20.820 --> 05:25.050
If you want to create containers of thread objects, then use a packaged task.

62
05:29.460 --> 05:34.440
If you have done asynchronous programming in other languages,
then you may notice that there are a few

63
05:34.440 --> 05:38.910
things I have not covered,
and these are actually missing from C++11.

64
05:40.370 --> 05:47.000
The biggest omission is continuations.
When you have a continuation, you can start off several tasks which

65
05:47.000 --> 05:47.870
run in a sequence.

66
05:49.970 --> 05:56.000
So you could say, for example, assemble 20 units, take them over there, then tell Joe in

67
05:56.000 --> 05:57.110
the workshop that you have done it.

68
05:59.020 --> 06:02.720
With C++11, you would have to say make up 20 units.

69
06:03.130 --> 06:03.790
Have you done that?

70
06:04.300 --> 06:05.420
Okay, take them over there.

71
06:05.770 --> 06:06.520
Have you done that?

72
06:07.070 --> 06:07.470
Okay.

73
06:07.780 --> 06:08.580
Tell Joe in the warehouse.

74
06:10.260 --> 06:14.610
So the difference is that the thread that is controlling all these tasks has to keep waiting for them

75
06:14.610 --> 06:20.460
and starting up new threads.
It cannot just start off several threads and let them run while it does something

76
06:20.460 --> 06:20.720
else.

77
06:22.760 --> 06:29.660
In C++11, we can only wait on a single future from async(). 
There is no support for waiting on multiple

78
06:29.660 --> 06:30.200
futures.

79
06:31.650 --> 06:34.750
So you cannot start off lots of tasks and wait for them all to finish.

80
06:35.310 --> 06:36.900
You have to check each one individually.

81
06:38.610 --> 06:42.690
There is also no support for waiting on any task.

82
06:42.690 --> 06:46.590
So you cannot start lots of tasks and then wait until the first one finishes.

83
06:48.110 --> 06:53.510
In C++20, the future implementation is going to be extended, so these will be supported.

84
06:53.840 --> 06:55.600
There is also a lot of other changes.

85
06:57.500 --> 07:03.680
At the moment, C++20 has been agreed.
It is just waiting the final stamp that says, it is an official

86
07:03.680 --> 07:07.510
standard and then we will have to wait for compilers to support this.

87
07:09.350 --> 07:14.180
If you cannot wait until then,
there is something called the concurrency TS, which has been around

88
07:14.180 --> 07:19.280
for several years and is basically a test bed for these new features.

89
07:21.810 --> 07:26.730
The other limitation, which we have mentioned before, is that there is not a concurrent queue in the

90
07:26.730 --> 07:30.720
standard and unfortunately there is not going to be one in C++20.

91
07:32.780 --> 07:34.550
OK, so that's it for this video.

92
07:34.670 --> 07:37.640
I'll see you next time, but meanwhile, keep coding!