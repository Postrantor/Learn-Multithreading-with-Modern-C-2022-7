WEBVTT

0
00:00.150 --> 00:00.750
Hello again.

1
00:01.050 --> 00:05.610
In this video, we're going to continue our overview of modern C++ features.

2
00:07.440 --> 00:12.930
We've already looked at auto and for ranges, which are two of the most useful, and we're going to

3
00:12.930 --> 00:16.290
look at another very useful feature, which is the lambda expression.

4
00:19.220 --> 00:25.550
A lambda expression allows us to write code inside other code if we need a local function.

5
00:25.820 --> 00:26.870
We can just write it there.

6
00:27.290 --> 00:28.550
We don't have to scroll up,

7
00:29.040 --> 00:33.890
think of a function name, write the code, then scroll back down and try to remember what we were doing

8
00:33.890 --> 00:34.370
before.

9
00:35.780 --> 00:37.490
Lambda expressions are anonymous

10
00:37.490 --> 00:44.150
functions which are defined inline. Other languages have similar concepts.

11
00:44.150 --> 00:51.710
They are often called closures. The main use for lambda expressions is for passing code as an argument

12
00:51.710 --> 00:55.490
to a function call, or returning it from a function call.

13
00:57.450 --> 01:00.390
Lambda expressions are another form of callable object.

14
01:00.840 --> 01:06.810
We already have function pointers, which is the C way of doing it, and functors, which is the

15
01:06.810 --> 01:11.340
traditional C++ way: you have a class which defines a function call operator.

16
01:11.760 --> 01:13.970
But lambda expressions are much more convenient.

17
01:17.500 --> 01:22.800
Defining a lambda expression is pretty similar to defining a function, except it doesn't have a name.

18
01:23.350 --> 01:29.290
Instead of the name, we put a pair of square brackets, then we write the function arguments

19
01:29.320 --> 01:33.550
as usual. You are allowed to omit the function arguments if there are not any.

20
01:35.210 --> 01:41.420
And then we writes the function body as if we were waiting an inline function, just a pair of curly braces

21
01:41.420 --> 01:42.920
with statements inside them.

22
01:46.330 --> 01:51.790
So we have something that looks like this, we have a pair of square brackets, then we have the arguments,

23
01:53.010 --> 01:55.060
then we have the body of the expression.

24
01:56.080 --> 01:59.450
In this case, it'll double the argument and return the value.

25
02:00.940 --> 02:07.560
Usually the compiler will be able to deduce the return type for you. If you are in C++11

26
02:07.870 --> 02:12.970
It will only do that if the lambda expression consists of a single statement with a return.

27
02:13.960 --> 02:16.320
If you have anything else, the compiler will assume it is void.

28
02:16.750 --> 02:22.870
So if you want to return a value from a more complex statement in C++ 11, you have to put this

29
02:22.870 --> 02:24.090
trailing return type.

30
02:24.580 --> 02:26.620
So that is an arrow and the type.

31
02:28.250 --> 02:34.220
That is not needed in C++ 14; the compiler can always deduce the return type. The only restriction

32
02:34.220 --> 02:37.530
is that the return type has to be the same in every path through the code.

33
02:38.030 --> 02:43.640
So if you have a branch and one branch returns a double and the other branch returns a string, that

34
02:43.640 --> 02:44.210
won't work.

35
02:49.480 --> 02:54.130
The main use for lambda expressions is as short, simple statements.

36
02:55.150 --> 02:59.890
They come in very useful for working with algorithms in the C++ Standard Library.

37
03:00.160 --> 03:05.560
These are functions which do various things like searching and sorting and swapping elements and so

38
03:05.560 --> 03:05.770
on.

39
03:06.750 --> 03:12.310
Usually they have overrides, which allow you to pass a callable object as an extra argument which

40
03:12.310 --> 03:13.210
will customize them.

41
03:15.040 --> 03:18.500
I've got an example here where we are going to start off by using a function pointer.

42
03:19.150 --> 03:25.330
So this function here is going to return true if its argument is even and false otherwise.

43
03:26.470 --> 03:32.020
So it takes an integer and it decides whether it is exactly divisible by two or not.

44
03:34.220 --> 03:41.990
And then we can use the count_if algorithm function from the standard library, this takes three arguments.

45
03:42.260 --> 03:46.700
The first two arguments are the range of iterators that we are going to be counting over.

46
03:47.360 --> 03:50.500
In this case, it is going to be all the elements in a vector.

47
03:51.290 --> 03:54.720
And then the third argument is a callable object.

48
03:55.850 --> 03:58.550
This will iterate through all the elements in the range.

49
03:58.880 --> 04:02.530
It'll call the predicate function with each element as its argument.

50
04:03.260 --> 04:08.960
And if the predicate returns true, it will increment a counter by one.

51
04:09.560 --> 04:15.680
And if false, it will leave it with its existing value. And then it will return the final value of

52
04:15.680 --> 04:16.160
the counter.

53
04:16.790 --> 04:22.160
So when we call it with these arguments, it is going to go through every element in the vector and return

54
04:22.160 --> 04:24.120
the number of elements which are even.

55
04:25.070 --> 04:26.270
So let's try that.

56
04:29.260 --> 04:33.100
So we have two elements with even values. That looks OK.

57
04:36.550 --> 04:39.580
So let's comment this out and use a lambda expression instead.

58
04:42.340 --> 04:49.090
So we're going to use a lambda expression so we have the pair of square brackets, then the argument. This argument

59
04:49.090 --> 04:52.630
is going to be an element, so it must be the same type as the elements.

60
04:53.120 --> 04:55.600
So it is an int and then we have the actual code.

61
04:58.330 --> 05:00.790
And the rest of the algorithm call is exactly the same.

62
05:01.090 --> 05:06.690
You'll notice that this definition actually goes inside the algorithm function call.

63
05:07.090 --> 05:08.920
So let's save that and run it.

64
05:11.910 --> 05:14.730
And there we are, the vector has two elements.

65
05:23.220 --> 05:29.730
The lambda expression that we have written cannot use any local variables. It can use global variables

66
05:29.730 --> 05:34.230
and it can use its arguments, but you can't use local variables. To do that,

67
05:34.440 --> 05:40.440
it needs to perform what's called a capture, and that is done by putting the name of the local variable

68
05:40.440 --> 05:41.640
inside the square brackets.

69
05:42.300 --> 05:49.920
So in this case, we have a local variable x, and then if we capture this variable, then the local

70
05:49.920 --> 05:53.760
variable x will be available inside the lambda body.

71
05:54.690 --> 05:56.120
This is captured by value.

72
05:56.340 --> 06:00.930
So the x in here will be a copy of the value in the local scope.

73
06:02.690 --> 06:09.470
If we want to modify the variable, we have to capture it by reference. This is done by putting an ampersand &

74
06:09.470 --> 06:10.770
in front of the verbal name.

75
06:11.240 --> 06:17.330
So if we have ampersand x inside the square brackets, then we can modify the variable inside.

76
06:17.480 --> 06:20.030
So that is actually a reference to the local variable.

77
06:20.540 --> 06:26.300
Any changes that we make inside the lambda body will affect the local variable.

78
06:26.780 --> 06:30.140
So in this case, we would set x to be 43.

79
06:34.490 --> 06:41.000
There are also special symbols which allow you to capture all local variables inside the scope. If we

80
06:41.000 --> 06:42.050
put an equals sign,

81
06:42.320 --> 06:45.510
That means we capture all the local variables by value.

82
06:46.670 --> 06:49.550
So in this case, we have x and y available inside.

83
06:52.020 --> 06:58.590
Or we can put an ampersand & which will capture every local variable by reference so we can modify the

84
06:58.590 --> 07:01.020
local variables from inside of the body.

85
07:01.920 --> 07:03.840
This is something you need to be a bit careful about.

86
07:07.470 --> 07:12.300
There are also options for only capturing some variables by value and some by reference.

87
07:15.570 --> 07:21.690
Finally, you can also use lambda expressions in member functions and you can access the member data of the

88
07:21.690 --> 07:25.950
class. To do that, you need to capture the "this" pointer.

89
07:26.310 --> 07:31.090
So "this" is the pointer to the object that the member function is being called on.

90
07:32.850 --> 07:37.380
So when you do that, you now have access to the members of that object.

91
07:39.220 --> 07:41.310
The way it's captured is slightly odd.

92
07:41.330 --> 07:46.600
It is actually a reference to the dereferenced pointer, which means it's actually a reference to the

93
07:46.600 --> 07:47.080
object.

94
07:48.010 --> 07:52.690
So this allows the lambda expression to modify data members without any unusual syntax.

95
07:54.370 --> 07:59.290
There are some changes in C++ 17 which allow you to be a bit more specific about how you want to do

96
07:59.290 --> 07:59.590
that.

97
08:04.220 --> 08:11.030
To give you an example of a lambda which performs a capture, I have rewritten the count_if program that

98
08:11.030 --> 08:14.930
we had before, so we still have count_if with the same elements.

99
08:15.710 --> 08:18.290
This time we are going to capture a local variable.

100
08:19.040 --> 08:24.740
And instead of finding out if [the element] is a multiple of two, we're going to find out if it's a multiple of

101
08:24.740 --> 08:26.080
this variable.

102
08:26.810 --> 08:29.300
So we have this local variable radix.

103
08:29.780 --> 08:36.140
We capture that by value and then the expression and then we perform the modulo expression using that

104
08:36.140 --> 08:36.530
value.

105
08:39.350 --> 08:43.430
The rest of the program is the same, so we are using the same vector.

106
08:45.930 --> 08:47.180
So let's try this out.

107
08:49.480 --> 08:53.440
So there you are, we have one element, which is an exact multiple of three.

108
08:55.860 --> 08:58.650
OK, so that's it for this video.

109
09:01.580 --> 09:02.580
I'll see you next time.

110
09:02.620 --> 09:04.700
But meanwhile, keep coding.