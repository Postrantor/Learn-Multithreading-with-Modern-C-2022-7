WEBVTT

0
00:00.150 --> 00:00.870
Hello again.

1
00:01.170 --> 00:05.400
In this video, we're going to continue our overview of modern C++.

2
00:06.090 --> 00:08.340
We're going to be looking at move semantics.

3
00:08.910 --> 00:13.140
I'm afraid this can be slightly dry, but we'll get through it.

4
00:16.420 --> 00:20.480
Move semantics is basically an optimized way of copying objects.

5
00:21.370 --> 00:27.640
There are some situations where you are copying an object to another object and you do not actually need

6
00:27.640 --> 00:31.620
to copy all the data in the object across to the other object.

7
00:31.930 --> 00:35.810
You can just move it. And to see what I mean by that,

8
00:36.250 --> 00:44.020
imagine that you are working with a file in Windows Explorer or the file manager in Mac or Linux.

9
00:46.050 --> 00:53.070
This file is in a particular folder, and you want the file to be available in another folder. You

10
00:53.070 --> 00:54.780
basically have two choices.

11
00:55.110 --> 00:59.160
You can copy the file, in which case the original file is unmodified.

12
00:59.850 --> 01:06.990
A new file will appear in the target folder and the operating system will copy the data from the original

13
01:06.990 --> 01:08.460
file to the new file.

14
01:10.590 --> 01:14.830
Alternatively, if you do not want to keep the original file, you can move it.

15
01:15.510 --> 01:18.380
In that case, the original file disappears.

16
01:19.230 --> 01:24.310
The new file appears in the folder and provided you are on the same disk,

17
01:24.510 --> 01:27.340
the operating system won't actually copy any data.

18
01:27.360 --> 01:31.350
It's not going to go into the file system and get the disk drive to spin up.

19
01:31.950 --> 01:37.710
It'll just change some field in a data structure to say that this file is now associated with that

20
01:37.710 --> 01:38.160
folder.

21
01:41.320 --> 01:48.490
C++ makes a lot of use of value semantics, which means copying. If you pass a value into a function

22
01:48.490 --> 01:51.250
or return it, then by default it will be copied.

23
01:52.000 --> 01:56.380
If you store some data in a container, then again it will be copied by default.

24
01:58.300 --> 02:03.610
If you have a program which makes good use of value semantics and you can replace some of these copies

25
02:03.610 --> 02:07.170
by moves, then you should see a significant increase in performance.

26
02:07.660 --> 02:09.430
So this is certainly worth knowing about.

27
02:13.260 --> 02:21.300
Let's imagine for the moment that we are in the C++ world before 2011, we have a vector with one million

28
02:21.300 --> 02:27.300
strings, we are passing this to a function and then we don't actually use the vector again.

29
02:29.800 --> 02:34.420
The vector is passed to the function by value, so this will cause a copy to be made.

30
02:35.350 --> 02:41.380
This will call the copy constructor of the vector, which will in turn call the copy constructor of

31
02:41.380 --> 02:42.300
each of its elements.

32
02:44.340 --> 02:50.580
So this is going to cause a vector of one million elements to be allocated, and then one million strings

33
02:50.580 --> 02:55.830
will be allocated within that vector and then the data for the one million strings will be copied from

34
02:55.830 --> 02:57.810
the original vector to the function argument.

35
02:58.980 --> 03:02.640
After the function returns, the original vector will be completely unaltered.

36
03:04.610 --> 03:09.560
So the program has gone through a huge amount of effort to make sure this vector is not modified.

37
03:13.030 --> 03:20.710
In C++ 11, the vector is moved into the function, so all the data that used to be in this vector is

38
03:20.710 --> 03:26.980
now in the function argument. After the function call returns, the original vector is now a completely

39
03:26.980 --> 03:30.080
empty object, but that doesn't matter because we're not going to use it.

40
03:31.240 --> 03:33.730
So we've saved all these allocations and copying.

41
03:37.940 --> 03:41.750
So the big question is, how can we take advantage of this improvement in performance?

42
03:43.780 --> 03:49.150
The way that this works is that data can only be moved into a function call argument if it is passed

43
03:49.150 --> 03:51.550
as something which is called an rvalue reference.

44
03:53.300 --> 03:56.900
If we are passing a temporary object, this will happen automatically.

45
03:58.300 --> 04:03.500
We can also tell the compiler that we want the variable to be used as an rvalue reference, which means,

46
04:03.500 --> 04:06.710
in effect, that we don't want to use the variable after the function call.

47
04:08.090 --> 04:09.740
So what is this rvalue reference?

48
04:12.230 --> 04:15.080
I'm afraid we're going to have to get a bit technical in this slide.

49
04:16.420 --> 04:21.610
In the C programming language, a value can either be an lvalue or an rvalue.

50
04:22.360 --> 04:26.920
If it can appear on the left of an assignment, then it's an lvalue.

51
04:27.790 --> 04:29.570
If it can only appear on the right,

52
04:29.710 --> 04:30.570
it's an rvalue.

53
04:31.060 --> 04:34.420
So the lvalue is on the left and the value is on the right.

54
04:35.980 --> 04:42.220
For example, if we have a variable, let's say, x, that can go on the left hand side of an equals sign,

55
04:42.670 --> 04:50.230
so it's an lvalue. if we have a literal like the number two, that can only go on the right of an

56
04:50.230 --> 04:50.840
equals sign.

57
04:51.430 --> 04:53.020
So that makes it an rvalue.

58
04:55.590 --> 05:01.830
We could put x on the right of an equal sign, but that's irrelevant. Provided it can appear on the

59
05:01.830 --> 05:02.820
left of an assignment,

60
05:02.850 --> 05:03.930
It's an lvalue.

61
05:06.530 --> 05:11.780
Another example from C is the return value from a function call. This can only go on the right of

62
05:11.780 --> 05:16.700
an equals sign and therefore, returning from a function returns and rvalue.

63
05:19.380 --> 05:22.300
In C++, unfortunately, it's a bit more complicated.

64
05:22.320 --> 05:27.300
We have operator overloading and constructors which don't fit into these simple rules.

65
05:28.660 --> 05:34.790
However, C++ wants to get the same basic answer so it changed the question. In C++,

66
05:34.810 --> 05:39.460
the question is, can you take the address using the address-of operator, ampersand?

67
05:40.910 --> 05:47.420
If you can take the address, it's an lvalue, if you can't take the address, it's an rvalue. For example,

68
05:47.420 --> 05:52.610
we can take the address of x. We can do ampersand x, therefore, x is an lvalue.

69
05:54.300 --> 05:59.310
We can't take the address of the literal two, so, two is an rvalue.

70
06:00.900 --> 06:06.350
We can't take the address of the return from the function, so that's an rvalue as well.

71
06:08.680 --> 06:13.330
And until 2011, this was really only of interest to people who wrote compilers.

72
06:19.180 --> 06:22.120
We all know and love references, I hope :)

73
06:23.780 --> 06:30.200
As you probably know, a reference is really a disguised pointer. When we create a reference, the

74
06:30.200 --> 06:36.350
compiler will actually arrange things so that we create a pointer. And every time we use this reference,

75
06:36.350 --> 06:39.500
the compiler will arrange for the pointer to be dereferenced.

76
06:41.240 --> 06:44.100
Obviously, this will only work if the variable has an address.

77
06:44.570 --> 06:47.240
So this requires that the variable is an lvalue.

78
06:48.410 --> 06:54.110
So in C++, if we want to be specific, we could say that this is a reference to lvalue.

79
06:57.530 --> 07:01.050
C++ 11 also has a reference to an rvalue.

80
07:01.670 --> 07:08.510
It's really a bit of syntax which indicates that something,  usually a function argument, is an rvalue.

81
07:11.050 --> 07:16.660
When we write an rvalue [reference], we put a double ampersand after the type as opposed to a single ampersand

82
07:16.660 --> 07:17.500
for an lvalue [reference].

83
07:18.670 --> 07:21.970
Here is a function whose argument is in rvalue reference.

84
07:25.800 --> 07:27.240
Let's go into the compiler.

85
07:27.570 --> 07:35.970
There's a function here which takes an rvalue reference as argument and it'll print out the words "rvalue reference" when

86
07:35.970 --> 07:41.140
it's called, just to make sure that we know. I'm going to call this with the value 2

87
07:41.160 --> 07:46.230
at first. You might want to think about why I have commented out the one with the argument

88
07:46.230 --> 07:46.560
y.

89
07:50.220 --> 07:54.360
So that compiles, it runs, it calls the function and prints out "rvalue reference".

90
07:58.280 --> 08:07.670
If I now uncomment this, let's see what happens... And we get a compiler error. The error says you cannot

91
08:07.670 --> 08:10.090
convert int to an rvalue reference.

92
08:11.920 --> 08:16.620
And this is because why is an lvalue. We can take the address of y, so it is an lvalue.

93
08:17.170 --> 08:22.310
And one of the rules is that you can't pass an lvalue to a function that takes rvalue reference.

94
08:23.590 --> 08:30.070
But supposing that we decided we don't want to use y again and we want to be able to move from y into

95
08:30.070 --> 08:32.980
the function argument, how do we do that?

96
08:37.100 --> 08:44.000
There is actually a function in C++ that is provided for this, it's called move(), and the purpose of

97
08:44.000 --> 08:46.340
move is to perform a cast on its argument.

98
08:46.670 --> 08:52.390
So in this case, move() is taking the argument y and it will return y cast to an rvalue reference.

99
08:53.120 --> 08:54.860
And then when we compile this...

100
08:57.200 --> 09:01.580
There we are, it compiles and it calls the function, which takes an rvalue reference.

101
09:06.390 --> 09:14.070
The reason why I usually put std colon colon in front of it is because move() is quite a popular

102
09:14.190 --> 09:15.330
name for functions.

103
09:15.860 --> 09:21.120
And if you're working on a large code base, it is quite possible that there's already a function in the global

104
09:21.120 --> 09:23.430
namespace called move() that takes a single argument.

105
09:23.790 --> 09:25.620
And in that case, you could get a conflict.

106
09:26.460 --> 09:29.130
So it's always wise to give the full name space.

107
09:33.660 --> 09:40.110
The name move is a bit of a misnomer. Just calling move on its own does not cause any data to be moved.

108
09:40.920 --> 09:43.680
It just casts the argument to an rvalue reference.

109
09:50.450 --> 09:56.720
In traditional C++, if we have a function that takes an argument without any qualification, so there's

110
09:56.720 --> 10:01.730
no ampersands anywhere, then in that case the argument will be copied.

111
10:02.000 --> 10:03.250
That is a "pass by value".

112
10:04.780 --> 10:09.880
If you do that in modern C++, it depends on the type that you are passing as an argument.

113
10:10.970 --> 10:16.420
If the type has a certain property and you're passing an rvalue of that type, then it can be moved.

114
10:17.980 --> 10:22.650
And this will work for all the library types that you and love, like vector and string and so on.

115
10:24.310 --> 10:29.860
If the class doesn't have this property or if the argument is not an rvalue, then it will just be

116
10:29.860 --> 10:30.250
copied.

117
10:31.900 --> 10:34.300
So that means you get the same behaviour that you did before.

118
10:35.620 --> 10:41.590
So if you have some code, where you have not yet had a chance to go through and add this property to all your classes,

119
10:42.100 --> 10:44.800
then it'll still work exactly the same way that it did before.

120
10:49.690 --> 10:57.750
So here is some code to show this. This is a function that takes a vector without using any references,

121
10:58.420 --> 11:00.270
so it's just like the function in the slide.

122
11:00.940 --> 11:03.610
We're going to print out the number of elements in this vector.

123
11:05.170 --> 11:08.680
In the main function, we've got our vector of one million strings.

124
11:09.460 --> 11:12.940
First, we're going to call it by passing an lvalue.

125
11:14.200 --> 11:15.340
So let's see what that does.

126
11:23.800 --> 11:28.270
So you can see it's called the function, and when it reached the function, it had one million arguments.

127
11:28.450 --> 11:34.390
And then after we returned from the function, the vector in main() still had one million arguments.

128
11:38.350 --> 11:43.720
So let's see now what happens if we move it, if we pass it as an rvalue reference.

129
11:51.460 --> 11:57.760
So, again, it has one million elements in the function, so it has been passed in as an argument, but

130
11:57.760 --> 12:03.190
in main(), after the function returns, the original vector has zero elements. It is empty.

131
12:03.760 --> 12:09.070
All the data has been sucked out of that vector and moved into the function call argument.

132
12:10.780 --> 12:15.830
So we have one million strings here in a vector, and then we pass that as an rvalue.

133
12:17.230 --> 12:24.380
So when we call this function, all the data from this vector is moved into the function call argument.

134
12:24.700 --> 12:32.800
So this arg, which is a local variable inside func(), now has the data. This variable, vec, has nothing.

135
12:34.030 --> 12:37.290
And then when we return, we have an empty vector.

136
12:39.730 --> 12:43.150
And it's not easy to tell, but I think the second one ran a bit quicker.

137
12:43.480 --> 12:44.890
Let's do it again, actually.

138
13:02.820 --> 13:04.680
Yeah, I think that one was quicker. Do you agree?

139
13:09.840 --> 13:11.940
OK, so that's it for this video.

140
13:12.570 --> 13:17.940
We'll come back and find out next time what this magic property is, that classes have, to be able to be

141
13:17.940 --> 13:19.320
passed by move. But

142
13:19.320 --> 13:21.120
until then, keep coding!