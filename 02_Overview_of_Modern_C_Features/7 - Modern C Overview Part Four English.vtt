WEBVTT

0
00:00.150 --> 00:00.700
Hello again.

1
00:00.900 --> 00:04.720
In this video, we're going to continue our overview of modern C++.

2
00:05.060 --> 00:07.130
We are going to finish off move semantics.

3
00:09.470 --> 00:16.160
We saw in the previous video that you can have a function which takes an argument by value, if that's

4
00:16.160 --> 00:18.980
passed as an lvalue, then the argument will be copied.

5
00:19.490 --> 00:22.610
If it's passed as an rvalue, then the argument will be moved.

6
00:24.240 --> 00:28.500
So in effect, we have one function, which takes two different types of arguments, but it behaves

7
00:28.500 --> 00:29.100
the same way.

8
00:29.910 --> 00:35.340
It's also possible to have two separate functions which behave differently, depending on how the argument

9
00:35.340 --> 00:35.970
was passed.

10
00:36.420 --> 00:39.850
And this is possible in C++ due to overloading of functions.

11
00:40.950 --> 00:46.140
We can have one function, which takes an lvalue reference which will copy its argument, and an overloaded

12
00:46.140 --> 00:49.530
function which will take an rvalue reference and move its argument.

13
00:51.030 --> 00:51.990
So let's look at this.

14
00:54.120 --> 01:01.650
So I've got a function here which takes an lvalue, a reference to const lvalue, and a function which

15
01:01.650 --> 01:03.240
takes an rvalue reference.

16
01:04.930 --> 01:07.080
I am going to call them with different arguments.

17
01:11.660 --> 01:17.450
First I am going to call it with the lvalue, then with an lvalue that is cast to rvalue reference and

18
01:17.450 --> 01:18.290
then with an rvalue.

19
01:19.730 --> 01:20.980
So let's see how this works.

20
01:23.060 --> 01:29.210
So when we call this with y, the version that takes the lvalue reference is called. When we pass it with

21
01:29.210 --> 01:32.930
y cast to rvalue then the rvalue reference version is called.

22
01:33.540 --> 01:37.150
And when we pass it with a literal, the rvalue reference is called.

23
01:37.910 --> 01:42.950
So we have these overloaded functions and the one which gets called depends on how we pass the arguments.

24
01:52.530 --> 01:59.430
When move semantics were first added to C++, they were just meant to be a form of optimization, but

25
01:59.430 --> 02:04.260
it quickly became obvious they could also be used to embody the concept of ownership.

26
02:05.550 --> 02:08.460
If we look at these two overloads a bit more closely,

27
02:08.940 --> 02:16.170
the one which takes an lvalue takes a reference to const, so this function can inspect the object.

28
02:16.530 --> 02:21.960
It can call the public member functions if they are const and it can access the values of any public

29
02:21.960 --> 02:24.090
data members, but not change them.

30
02:25.720 --> 02:30.710
The argument is an lvalue, which means it has an address in memory defined somewhere in the program.

31
02:31.060 --> 02:34.360
So in a way, you can think of that as being owned by someone.

32
02:36.170 --> 02:42.540
On the other hand, the rvalue does not have any address. The object has been moved into this function,

33
02:42.560 --> 02:45.980
so this function can do whatever it likes and it won't affect anyone else.

34
02:47.310 --> 02:50.520
So you can think of the function as becoming the owner of this object.

35
02:52.640 --> 02:58.670
An rvalue corresponds to something that is not owned by anyone. If it's a literal or a temporary object,

36
02:58.910 --> 03:03.350
then it lives in memory which is managed by the compiler, which is outside of the control of the

37
03:03.350 --> 03:03.830
program.

38
03:05.570 --> 03:11.450
On the other hand, if it is an lvalue and we have called on it, then that means it no longer really

39
03:11.450 --> 03:12.600
exists for the owner.

40
03:12.620 --> 03:15.620
I mean, it's still there, but as a kind of shell of an object.

41
03:18.060 --> 03:23.340
In all these cases, the function now becomes the owner of the object, so you can think of the ownership

42
03:23.340 --> 03:25.680
as being transferred to this function.

43
03:30.590 --> 03:37.730
C++ has some library types which cannot be copied but can be moved. One of these, which you probably

44
03:37.730 --> 03:39.260
all know is fstream.

45
03:39.800 --> 03:42.230
Another one is unique underscore ptr.

46
03:42.650 --> 03:47.960
This is a smart pointer which was introduced in C++. We don't actually need it in this course,

47
03:47.960 --> 03:49.720
so I am not going to talk about it.

48
03:50.480 --> 03:54.590
And there are also some classes used in multithreading which we will meet later on in this course.

49
03:56.750 --> 04:01.470
These types own a resource: the file stream owns a file pointer.

50
04:01.910 --> 04:10.070
Typically, the unique_ptr owns some allocated memory. The way these work are that the objects will acquire

51
04:10.070 --> 04:13.560
ownership of the resource in the constructor: the fstream will open the file,

52
04:13.580 --> 04:16.070
the unique pointer will allocate the memory.

53
04:17.030 --> 04:23.630
And then in the destructor, the object will release ownership: the file would be closed or the memory

54
04:23.630 --> 04:24.520
will be released.

55
04:26.950 --> 04:34.660
Only one object can own a given resource at a time, so only one unique_ptr can own some allocated

56
04:34.660 --> 04:37.000
memory, only one file stream

57
04:37.000 --> 04:39.790
can have a particular instance of an open file.

58
04:41.310 --> 04:43.510
So that's why these objects can't be copied.

59
04:43.530 --> 04:49.320
Because if you copy it, you have two objects which own the same resource and that is not going to work.

60
04:50.400 --> 04:56.070
However, it is possible to transfer the ownership from one object to another, and we can do that by

61
04:56.070 --> 04:57.290
moving the resource.

62
04:57.750 --> 05:04.470
So the resource is just held as a data member and that data can be moved just like any other data member.

63
05:08.210 --> 05:14.210
If we work through this with fstream, fstream has a data member, which is a file pointer or some sort of file

64
05:14.210 --> 05:14.660
object.

65
05:16.260 --> 05:21.190
The fstream constructor will open some file, which is given as an argument to the constructor.

66
05:22.800 --> 05:27.870
There are some other ways, but this is the most relevant to this discussion. And then the destructor

67
05:27.870 --> 05:28.800
will close the file.

68
05:31.130 --> 05:34.320
An fstream object cannot be copied, but it can be moved.

69
05:34.730 --> 05:41.130
This will cause the file object to be transferred from the source object to the new copy.

70
05:41.960 --> 05:46.460
The source object will give up its ownership of the file object and it will be left empty.

71
05:47.390 --> 05:52.910
The target object will take ownership of the file object, and it's going to be responsible for managing

72
05:52.910 --> 05:53.630
its lifetime.

73
05:54.590 --> 05:58.220
And then when the target object is destroyed, the file is closed.

74
06:02.840 --> 06:09.050
C++ has had copy and assignment operators for a long time. These are needed in case an object needs

75
06:09.080 --> 06:13.630
to do anything special when you are copying it or assigning to it.

76
06:15.390 --> 06:20.800
In C++11, there are two new member functions which do the same when you are moving an object.

77
06:21.510 --> 06:26.310
So we now have a move constructor, which is like the copy constructor, but it does a move [operation].

78
06:26.850 --> 06:32.940
And the move assignment operator, which is like the assignment operator, or as it is now known, the copy

79
06:32.940 --> 06:35.490
assignment operator, but it does a move [operation].

80
06:37.210 --> 06:42.850
The prototypes look a bit different. You might expect that they would have a double ampersand instead of

81
06:42.850 --> 06:47.050
a single ampersand because they're going to be taking an rvalue to move from.

82
06:49.200 --> 06:54.090
These are not made const because the object is going to be moved from, it's going to be modified,

83
06:54.090 --> 06:59.280
so it can't be const and we also use this noexcept key word.

84
07:00.790 --> 07:06.970
This is another new feature in C++ 11. It means that the function promises it is not going to throw

85
07:06.970 --> 07:11.140
an exception or call any other functions that might throw an exception.

86
07:12.820 --> 07:18.640
In C++ 98, there was throw with an empty bracket which did the same thing.

87
07:21.020 --> 07:23.990
There was also throw with arguments in which is now being dropped.

88
07:29.890 --> 07:34.150
So finally, we can find out what the special property is, that classes have to have to be moved.

89
07:36.570 --> 07:40.540
In traditional C++, when we have an argument, it's always copied.

90
07:40.680 --> 07:47.670
So this slide really is a more complete version of a slide that we had in the last video. In modern C++.

91
07:47.700 --> 07:52.920
the argument can be moved if it is an rvalue, and also the type must be movable.

92
07:54.630 --> 08:00.960
This requires that the class has a move constructor, and all the C++ library types were rewritten in

93
08:00.960 --> 08:07.130
C++11 to give them a move constructor and move assignment operator. Of course, being C++.

94
08:07.140 --> 08:11.370
there have to be some exceptions and they are actually both to do with multi threading.

95
08:13.360 --> 08:19.840
If the type doesn't have a move constructor or we pass an lvalue to the function, then the argument

96
08:19.840 --> 08:20.530
will be copied.

97
08:21.280 --> 08:25.120
So if we have old code, that's going to work exactly the same way as it did before.

98
08:27.890 --> 08:29.720
OK, so that's it for this video.

99
08:30.200 --> 08:33.290
I'll see you next time, but meanwhile, keep coding.