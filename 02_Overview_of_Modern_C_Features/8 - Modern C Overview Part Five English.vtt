WEBVTT

0
00:00.300 --> 00:06.030
Hello again. In this video, we are going to finish off our overview of the modern C++ features we need

1
00:06.030 --> 00:06.720
for this course.

2
00:07.470 --> 00:11.820
I was only planning to make four videos, but there is slightly too much material.

3
00:14.790 --> 00:22.440
If we want to make a class that cannot be copied in traditional C++, the only way to do this was to

4
00:22.440 --> 00:26.640
declare the copy constructor and the assignment operator as private.

5
00:27.690 --> 00:29.790
Actually, let's look at that in the compiler.

6
00:32.040 --> 00:41.260
I've got a class here which has a private copy constructor and assignment operator. Visual C++ has put

7
00:41.280 --> 00:44.430
a squiggle there, even though I've turned off all the squiggles in the menus!

8
00:46.260 --> 00:49.890
We've also got a default constructor, which is public.

9
00:50.370 --> 00:53.430
If we don't have that, we can't create any objects of this class.

10
00:55.820 --> 00:57.840
So let's start off by doing that.

11
00:59.330 --> 01:03.320
So there we are, that's all okay, just calling the default constructor.

12
01:07.560 --> 01:15.360
If we try to call the copy constructor, we get a compiler error, it says "cannot access private member".

13
01:17.090 --> 01:21.230
The copy constructor is private, so it can't be called from outside the class.

14
01:24.570 --> 01:30.870
And if we do the same for the assignment operator, we have the same problem, "cannot access private

15
01:30.960 --> 01:31.300
member".

16
01:31.950 --> 01:36.150
So that would be how to make a class which can't be copied in traditional C++.

17
01:38.710 --> 01:43.390
In modern C++, you can just say that the function equals delete.

18
01:43.750 --> 01:49.630
So this applies to all the special functions: default constructor, copy constructor, assignment

19
01:49.630 --> 01:52.840
operator, move constructor and move assignment operator.

20
01:54.520 --> 01:58.270
When you say "equals delete", the compiler will pretend they do not exist.

21
01:58.900 --> 02:04.630
So this is another way to prevent an object from being copied and it's probably a bit nicer than making

22
02:04.630 --> 02:05.380
things private.

23
02:07.340 --> 02:13.010
Instead of putting "equals delete", we can put "equals default", and this means that we want a default

24
02:13.010 --> 02:15.450
version of that special member function.

25
02:15.860 --> 02:19.370
So, for example, if we put the copy constructor equals default.

26
02:19.700 --> 02:26.330
That means that we want the compiler to generate a default copy constructor for us, which will call

27
02:26.330 --> 02:29.320
the copy constructor of all the members of the class.

28
02:32.070 --> 02:34.000
This is useful for two reasons.

29
02:34.350 --> 02:39.590
First of all, you can see immediately from looking at the class which special member functions it has.

30
02:40.410 --> 02:45.780
If you rely on the compiler to generate them for you, then you are doing it implicitly, which means

31
02:46.140 --> 02:47.370
you have to remember it.

32
02:48.120 --> 02:50.640
And it is not obvious immediately when you look at the class.

33
02:52.830 --> 02:58.020
With defaults, you can see immediately that it has a copy constructor, which is the default.

34
02:59.460 --> 03:03.260
The other benefit is that you do not have to actually write the copy constructor yourself.

35
03:03.510 --> 03:08.340
There's no possibility that you can get it wrong or forget to update it when the class is changed.

36
03:09.540 --> 03:10.500
And that's always good.

37
03:12.570 --> 03:15.090
So here we are again with a more modern version.

38
03:15.090 --> 03:22.230
I'm using "equals delete" to prevent the copy constructor and assignment operator from being called.

39
03:23.370 --> 03:29.340
I have also used "default" for the move constructor and the move assignment operator.

40
03:30.790 --> 03:34.600
And in fact, I can also use "default" for the default constructor.

41
03:36.140 --> 03:40.550
So in this case, it is just going to call that the default constructor for all the members of the class.

42
03:41.360 --> 03:43.820
At least it would if the class had any members!

43
03:47.520 --> 03:49.270
(Just comment this out for the moment)

44
03:53.060 --> 03:54.240
OK, so there we are.

45
03:54.290 --> 03:57.610
I got some warnings about not using the variables, but that doesn't matter.

46
04:00.780 --> 04:08.070
And then, just to prove that we cannot use the copy constructor... Error, "attempting to reference a deleted function".

47
04:13.960 --> 04:18.610
And the same error for the assignment operator "attempting to reference a deleted function".

48
04:22.180 --> 04:24.640
But I can still use the move operators.

49
04:26.830 --> 04:27.170
There we are.

50
04:32.350 --> 04:33.980
Yeah, so that's all fine.

51
04:34.000 --> 04:34.920
So that all compiles.

52
04:37.450 --> 04:42.930
So when we delete the copy constructor and the assignment operator, we can't copy or assign objects

53
04:42.940 --> 04:43.560
of this class.

54
04:44.290 --> 04:49.960
When we use default, move constructor and move assignment operators, then the compiler will generate

55
04:50.830 --> 04:51.550
default ones.

56
04:54.820 --> 04:57.100
And the final topic is random numbers.

57
04:59.540 --> 05:06.500
C++11 provided much better facilities for working with random numbers. The old rand() function has a

58
05:06.500 --> 05:07.360
number of issues.

59
05:07.850 --> 05:13.460
The worst problem is if you want a different range of numbers, by default, you will get an integer between

60
05:13.460 --> 05:16.650
zero and some compiler-defined maximum.

61
05:17.330 --> 05:23.270
If you want, say, a range of floating point numbers from one to 100, you have to do some arithmetic

62
05:23.480 --> 05:29.020
which will scale the numbers and that will introduce bias so the numbers are not properly random.

63
05:31.410 --> 05:36.560
The facilities in C++11 are much higher in standard, but they are a little bit more involved.

64
05:37.910 --> 05:42.470
There are actually two different elements. The first one is a random number engine.

65
05:43.460 --> 05:46.370
This will generate a sequence of random numbers.

66
05:48.320 --> 05:50.470
The second one is a distribution object.

67
05:50.780 --> 05:53.430
We can use this to scale the sequence of numbers.

68
05:53.750 --> 05:59.840
So if we want floating point numbers between one and 100, we just create a distribution object, which

69
05:59.840 --> 06:07.040
does that. You can also use different statistical distributions. For random numbers,

70
06:07.070 --> 06:12.530
we normally want a uniform distribution, which means that each number is equally likely, but there

71
06:12.530 --> 06:18.080
are lots of alternatives, like Gaussian,  Poisson, binomial and Bernoulli.

72
06:19.400 --> 06:24.560
The way these work is that they are actually callable objects. When you call the random number engine, it

73
06:24.560 --> 06:26.480
returns the next number in the sequence.

74
06:27.200 --> 06:30.220
And when you call it the distribution object, it will return

75
06:30.380 --> 06:35.090
that number, scaled to fit into the range and distribution that you asked for.

76
06:38.600 --> 06:46.430
So here we are, we have a random number engine. When this is created, it will generate a sequence of

77
06:46.430 --> 06:47.450
random numbers.

78
06:49.480 --> 06:57.190
And then we create a distribution. In this case, we want ints between zero and 100, so we use

79
06:57.190 --> 07:03.580
the integer version with the parameter as int and the constructor arguments are zero and 100.

80
07:08.790 --> 07:09.810
Let's see what that does.

81
07:11.220 --> 07:15.480
So there we are, we have 10 random integers between zero and 100.

82
07:19.330 --> 07:25.030
So the way this works is that we call the distribution object and we give the engine as the argument

83
07:25.030 --> 07:26.420
to the distribution call.

84
07:27.010 --> 07:33.850
So this will cause the random number engine to return the next number, then the distribution will scale it and return

85
07:33.850 --> 07:34.480
the result.

86
07:41.350 --> 07:46.360
We can also use the same technique for floating point numbers, let's say we want doubles between zero

87
07:46.360 --> 07:50.810
and one. So we use a floating point distribution.

88
07:51.700 --> 07:56.050
We give the parameter as double and the constructor arguments are zero and one.

89
07:56.890 --> 08:00.310
And then we call the distribution with the engine as argument again.

90
08:05.580 --> 08:09.360
And then we have 10 floating-point random numbers between zero and one.

91
08:17.620 --> 08:23.390
Normally, these engine and distribution instances should be made global or static.

92
08:24.370 --> 08:27.580
The reason is that creating them is fairly time consuming.

93
08:28.520 --> 08:34.380
When you create a random number engine, it generates the entire sequence of random numbers in its constructor.

94
08:36.400 --> 08:38.660
Every time you create a new engine,

95
08:38.680 --> 08:40.670
the sequence starts again.

96
08:40.690 --> 08:44.170
So if you are not using a "seed", you will get the same numbers every time.

97
08:46.930 --> 08:50.650
And in most applications, you're only going to need one random number engine anyway.

98
08:52.590 --> 08:53.260
So there we are.

99
08:53.280 --> 09:01.020
That's the end of the C++11 features. Some of these may seem a bit of a diversion or a bit irrelevant,

100
09:01.200 --> 09:04.410
but they are all used in the course, and I hope you will find them useful.

101
09:05.130 --> 09:07.230
Okay, so that's enough language features!

102
09:07.230 --> 09:08.580
Let's start doing some multithreading!