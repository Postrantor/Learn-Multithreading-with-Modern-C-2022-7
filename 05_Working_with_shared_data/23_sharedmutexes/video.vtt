WEBVTT

0
00:00.300 --> 00:00.880
Hello again.

1
00:01.140 --> 00:03.870
In this video, we are going to look at shared mutexes.

2
00:05.760 --> 00:11.610
So we now know how to use mutexes to make sure that only one thread can execute in a critical region

3
00:11.610 --> 00:12.570
at any one time.

4
00:14.050 --> 00:20.470
That is very useful, but occasionally it is a bit too restrictive.
Let's imagine that we have a situation

5
00:20.740 --> 00:28.150
where we have some data which is accessed for reading very frequently, but only very rarely modified.

6
00:29.790 --> 00:35.730
If we use the techniques we have learnt so far, this means that every time a thread wants to read this

7
00:35.730 --> 00:42.660
shared data, it has to get an exclusive lock on it and no other threads can access it, even if it is

8
00:42.660 --> 00:43.680
just to read it.

9
00:46.260 --> 00:52.200
So this means if we have, say, 1000 threads which read the data and only one thread which writes

10
00:52.200 --> 00:58.330
to it, then 999 times out of 1000, we are looking the mutex when we do not need to.

11
00:58.590 --> 01:00.720
And that is going to have a big effect on performance.

12
01:01.570 --> 01:07.020
On the other hand, on the occasional time when there is a thread which modifies the data, then we

13
01:07.020 --> 01:11.040
want to make sure that all the reading threads are locked out to prevent a data race.

14
01:11.310 --> 01:13.860
So we cannot just take the mutexes off.

15
01:15.500 --> 01:21.140
If you were using C++11, there was not very much you could do about this, at least not using standard

16
01:21.140 --> 01:28.370
C++.
C++14 provided a mutex which could be used for this and a type of lock.

17
01:29.090 --> 01:36.320
C++17 improved the mutex by removing the timeout functions, which the C++14 mutex had.

18
01:38.110 --> 01:39.870
So let's find out how all this works,

19
01:42.820 --> 01:49.400
The C++17 shared mutex, which we are going to look at, is defined in the <shared_mutex> header.

20
01:51.010 --> 01:54.430
There are actually two different ways in which it can be locked.

21
01:54.910 --> 02:00.220
The first one is exactly the same as every other mutex that we have looked at so far, which is to get

22
02:00.220 --> 02:01.180
an exclusive lock.

23
02:02.050 --> 02:08.800
If a thread has an exclusive lock on this mutex, then no other thread can acquire a lock until this

24
02:08.800 --> 02:10.030
thread releases the lock.

25
02:11.560 --> 02:19.330
There is also a shared lock. When a threat has a shared lock, any other thread can also acquire a shared

26
02:19.330 --> 02:19.930
lock on the mutex.

27
02:20.470 --> 02:23.650
It does not have to wait for this thread to release the lock.

28
02:25.550 --> 02:32.030
If another thread wants to get an exclusive lock, it has to wait until all the threads which have shared

29
02:32.030 --> 02:33.310
locks release them.

30
02:34.160 --> 02:39.550
And also if the thread has an exclusive lock, then no one can get a shared lock until that is released.

31
02:43.130 --> 02:49.140
To get an exclusive lock is exactly the same as the other mutexes, so we can use lock_guard, unique_lock

32
02:49.140 --> 02:50.540
or scoped_lock as we wish.

33
02:51.770 --> 02:54.950
This will give the thread exclusive access to the critical region.

34
02:55.430 --> 03:01.220
Only one thread can access it. If another thread wants to access the critical region,

35
03:01.500 --> 03:05.180
it will have to wait until this thread releases the exclusive lock.

36
03:07.400 --> 03:11.450
There is also a shared_lock which provides shared access.

37
03:12.870 --> 03:18.210
Any thread can share access to the critical region with other threads which also have shared locks.

38
03:19.290 --> 03:24.630
If there is a thread which has an exclusive lock, then the thread will have to wait to acquire its shared lock.

39
03:27.170 --> 03:29.090
So how would we use this in code?

40
03:29.820 --> 03:38.600
We would create an instance of the shared mutex. We would create read and write task functions.

41
03:38.600 --> 03:45.110
The write function will get an exclusive lock on the mutex, so only one thread can write to the shared data at

42
03:45.110 --> 03:45.800
any one time.

43
03:46.820 --> 03:54.050
The reader threads will get shared locks on the mutex so any thread can read the data provided that

44
03:54.050 --> 03:54.950
no-one is writing to it.

45
03:56.310 --> 04:00.100
So let's have a look at some code that does this. So here we are.

46
04:00.120 --> 04:02.510
I have got a write task function.

47
04:03.840 --> 04:06.470
This gets a lock guard on the mutex.

48
04:06.720 --> 04:08.820
So this is going to acquire an exclusive look.

49
04:10.410 --> 04:15.510
While this write task is executing its critical region, no other thread can access it.

50
04:17.690 --> 04:24.440
The read test function takes a shared lock on the mutex, so we could have many threads executing this

51
04:24.450 --> 04:29.870
read task at the same time. And instead of sharing data, I am just going to print out a number, which

52
04:29.870 --> 04:31.580
depends on the threads.

53
04:34.030 --> 04:41.920
I have included the shared_mutex header. In the main() function, I am creating lots of threads which read

54
04:41.920 --> 04:47.980
and one thread which writes. When you want to create lots of threat objects, it is useful to put them

55
04:47.980 --> 04:48.800
into a vector.

56
04:49.570 --> 04:54.640
Then when you populate the vector, the thread objects cannot be copied, but they can be moved.

57
04:54.910 --> 05:00.670
So this is going to transfer ownership of the underlying system thread from the thread object into

58
05:00.670 --> 05:01.690
the vector element.

59
05:03.410 --> 05:10.430
So I create some reading threads here, I create a writer thread, and then I create some more reading

60
05:10.430 --> 05:10.790
threads.

61
05:11.150 --> 05:14.900
And then finally I iterate over the threads and join each one.

62
05:15.380 --> 05:20.000
I need to use the reference version of auto here because the thread objects cannot be copied.

63
05:21.650 --> 05:23.090
Okay, so let's see how this works.

64
05:25.010 --> 05:27.140
So we have some reading threads start up.

65
05:27.140 --> 05:30.560
They all get a shared lock and they can all access the critical region.

66
05:30.920 --> 05:36.110
The write thread gets an exclusive lock and now all the read threads which come afterwards have to wait.

67
05:38.060 --> 05:43.430
And when - yes, there it is! - the write thread releases its look and then the other reading threads

68
05:43.580 --> 05:44.120
can run.

69
05:45.510 --> 05:47.820
And you will notice the output is slightly scrambled up.

70
05:50.090 --> 05:50.620
OK.

71
05:52.810 --> 05:55.720
Let's remind ourselves about the conditions for a data race.

72
05:56.080 --> 06:00.850
I am going to keep displaying this slide until you see it in your dreams! Or perhaps that should be nightmares!!

73
06:02.320 --> 06:05.170
So the condition for a data race is when we have:

74
06:06.710 --> 06:12.530
two or more threads which access the same memory location and at least one of the threads modifies

75
06:12.530 --> 06:13.620
the memory location.

76
06:13.850 --> 06:14.860
So that is the case here.

77
06:15.380 --> 06:17.900
We have a reading thread and writing thread.

78
06:19.670 --> 06:22.850
These are safe only if the accesses are synchronized in some way.

79
06:23.390 --> 06:26.870
Each access is made to happen before the next,

80
06:26.870 --> 06:28.640
or the accesses are made atomically.

81
06:30.160 --> 06:33.970
So how does using a shared mutex help us prevent a data race?

82
06:36.740 --> 06:44.390
So we have these potentially conflicting reader and writer threads. The writer threat cannot get an exclusive

83
06:44.390 --> 06:50.030
lock and execute the critical region until all the reader threads, which are currently accessing the

84
06:50.030 --> 06:52.400
critical section, release their shared locks.

85
06:53.090 --> 06:59.210
So this means that the accesses by these reader threads will happen before the access by the writer thread.

86
07:01.100 --> 07:08.360
If the writing thread has an exclusive lock and reader threads want to get a shared lock, they cannot do that

87
07:08.360 --> 07:13.640
until the writer has finished accessing the critical section and releases the exclusive lock.

88
07:14.420 --> 07:20.180
So the access by the writing thread will happen before the access by these other reader threads.

89
07:21.020 --> 07:28.190
So we have the reader and writer threads "happening before" the ones which could conflict. The accesses by

90
07:28.220 --> 07:33.620
multiple reading threads do not have the happens before ordering, but that does not matter because they

91
07:33.620 --> 07:36.490
do not modify the data, so they cannot conflict.

92
07:37.820 --> 07:44.570
So we never have a situation in which a reader and a writer thread are executing the critical section

93
07:44.570 --> 07:45.340
at the same time.

94
07:46.350 --> 07:49.900
So there is no situation in which the reader and writer threads are interleaved.

95
07:52.530 --> 07:54.360
OK, so that is it for this video.

96
07:54.750 --> 07:55.660
I will see you next time.

97
07:55.710 --> 07:57.480
But meanwhile, keep coding!