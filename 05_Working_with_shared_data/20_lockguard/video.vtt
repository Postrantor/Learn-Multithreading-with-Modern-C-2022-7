WEBVTT

0
00:00.180 --> 00:00.780
Hello again.

1
00:01.020 --> 00:07.500
In this video, we are going to look at the lock_guard class in the standard library. This solves one

2
00:07.500 --> 00:09.450
of the problems with mutexes.

3
00:11.890 --> 00:18.280
The problem is that if an exception is thrown in the critical region, the mutex is left locked.

4
00:19.300 --> 00:20.470
So let's have a look at that.

5
00:22.710 --> 00:29.280
So this is the code that we had before. When the thread goes into the loop, it looks the mutex.

6
00:30.830 --> 00:35.960
It can display its output without having any other thread interfere with this, and then it unlocks

7
00:35.960 --> 00:38.930
the mutex, which will allow some other thread to run.

8
00:40.450 --> 00:42.940
So what happens if we throw an exception in here?

9
00:49.110 --> 00:49.450
Right.

10
00:49.470 --> 00:50.310
Well, that is not very good!

11
00:50.340 --> 00:51.990
The program has been terminated.

12
00:54.110 --> 00:58.250
So we can see that one thread has managed to do one line of output.

13
01:00.440 --> 01:05.270
What has happened is that the first thread to run has gone into the loop. It has locked its mutex,

14
01:05.630 --> 01:09.020
it has done its output, and then the exception is thrown.

15
01:09.710 --> 01:13.520
When that happens, the destructors are called for all the objects in the scope.

16
01:14.580 --> 01:20.580
Well, there are not really any, except for the variable i, I suppose. And then the thread will jump out

17
01:20.580 --> 01:23.130
of the loop and look for an exception handler.

18
01:24.670 --> 01:25.270
There aren't any.

19
01:25.300 --> 01:29.080
So the thread is terminated and that causes the entire program to terminate.

20
01:30.670 --> 01:32.830
So let's put in an exception handler.

21
01:44.720 --> 01:48.560
Okay, well, the program is still running, but it is not doing very much.

22
01:52.740 --> 02:00.150
So what happened this time, was that the first thread to run locked the mutex. It did some output, the exception

23
02:00.210 --> 02:03.900
was thrown, the thread that jumped into the catch handler.

24
02:05.210 --> 02:13.100
The problem is that the threat did not call unlock, so this mutex is still locked and all the threads

25
02:13.100 --> 02:16.550
which are waiting for a lock on that mutex are going to be waiting forever.

26
02:17.480 --> 02:23.140
The program is deadlocked because nothing can happen until this thread unlocks the mutex.

27
02:23.540 --> 02:26.870
But this thread has stopped running, so it cannot unlock the mutex.

28
02:29.000 --> 02:33.680
Okay, so the obvious way to do this is to unlock the mutex in the catch handler.

29
02:35.900 --> 02:37.760
So let's see what effect that has.

30
02:41.060 --> 02:47.470
OK, so the program is now run and successfully completed - or some values of "successfully" anyway!

31
02:48.440 --> 02:50.300
Each thread has run once.

32
02:53.090 --> 03:00.110
The first thread to run locks the mutex and prints some output, then the exception is thrown and in the exception

33
03:00.110 --> 03:06.620
handler, it unlocks the mutex. Then the next thread can run and the same thing happens again.

34
03:07.550 --> 03:09.730
That throws an exception and unlocks the mutex.

35
03:09.740 --> 03:13.970
Then the third thread runs and - same problem again.

36
03:15.110 --> 03:22.130
We only get one output because the handler is outside the loop. So we could move the handler inside

37
03:22.130 --> 03:22.550
the loop.

38
03:29.190 --> 03:30.340
(Now let's see what happens)

39
03:32.230 --> 03:40.120
OK, so each thread has been able to execute all the outputs in its loop, and then if we remove this

40
03:40.120 --> 03:45.100
print statement, then we should get what looks like a normal output.

41
03:45.490 --> 03:46.270
Yes, there we go.

42
03:46.780 --> 03:48.690
OK, so we have solved the problem.

43
03:51.780 --> 03:56.790
So the problem again, the mutex is not unlocked if an exception is thrown.

44
03:58.880 --> 04:01.610
All the threads which are waiting to acquire the lock will be blocked.

45
04:02.660 --> 04:05.000
main() is joined on the blocked threads.

46
04:05.270 --> 04:08.780
So main() is going to be blocked as well, so the whole program is deadlocked.

47
04:12.090 --> 04:18.600
So this is a problem with the mutex. Whenever we call lock(), we must put in a corresponding call to

48
04:18.600 --> 04:22.350
unlock(), either in the code or an exception handler.

49
04:23.770 --> 04:29.980
If we have code which has many different return paths, then they all have to have an unlock() and we have

50
04:29.980 --> 04:31.510
to be careful not to unlock twice.

51
04:32.990 --> 04:37.580
So this is why programmers do not normally use the mutex directly.

52
04:40.490 --> 04:46.400
There are some classes in the standard library which we can use to wrap the mutex, and these follow the

53
04:46.400 --> 04:55.530
RAII idiom for managing resources, "Resource Allocation Is Initialization", which means that we allocate

54
04:55.550 --> 04:59.830
the resource in the constructor and we release it in the destructor.

55
05:00.880 --> 05:09.310
Some examples you may have met are the fstream for managing files, unique_ptr for managing allocated

56
05:09.310 --> 05:09.730
memory.

57
05:10.480 --> 05:14.700
In both cases, the file is opened in the constructor and closed in the destructor.

58
05:15.160 --> 05:20.150
The memory is allocated by the unique_ptr constructor and released in the destructor.

59
05:20.920 --> 05:24.760
In this case, the resource that the class manages is a lock on a mutex.

60
05:26.270 --> 05:33.410
The constructor will take the mutex object as its argument and it will lock it and the destructor will

61
05:33.410 --> 05:34.010
unlock it.

62
05:35.290 --> 05:40.810
If we create an object of one of these classes as a local variable, that means that the mutex will

63
05:40.810 --> 05:43.930
be automatically unlocked when the object goes out of scope.

64
05:46.160 --> 05:47.870
If an exception is thrown,

65
05:48.930 --> 05:55.290
Or you have 57 different return paths from your thread function and someone adds a 58th, then the

66
05:55.320 --> 05:56.850
mutex will always be unlocked.

67
06:00.130 --> 06:07.510
The first wrapper class we are going to look at is lock_guard. This is a very basic wrapper class. It only

68
06:07.510 --> 06:14.620
has two member functions, the constructor and the destructor which lock and unlock the mutex. We need

69
06:14.620 --> 06:22.930
to give the type of the mutex as a parameter to the lock_guard, unless we're using C++ 17, in which

70
06:22.930 --> 06:24.510
case the compiler can work it out.

71
06:25.030 --> 06:30.640
So we just put lock_guard, the name of the variable and the mutex argument.

72
06:34.200 --> 06:40.530
So we do not need to put an explicit lock() and unlock() calls to the mutex, we just create a lock_guard

73
06:40.770 --> 06:47.390
instance and we pass the mutex as its argument, and then we do that just before the critical region.

74
06:48.210 --> 06:53.250
And then when we get to the end of the scope, the local variable will be destroyed.

75
06:53.280 --> 06:55.950
The destructor is called and that will unlock the mutex.

76
06:56.950 --> 06:58.080
Let's try this out.

77
06:59.960 --> 07:01.630
There we are. Lovely!

78
07:03.290 --> 07:08.900
So when we create the lock_guard instance here, that will lock the mutex and then that will mean that the critical

79
07:08.900 --> 07:15.770
region can only be executed by this thread, and then the mutex will always be unlocked, even if we

80
07:15.770 --> 07:16.580
throw an exception...

81
07:30.620 --> 07:31.370
So there it is.

82
07:31.820 --> 07:38.840
We do not need to do anything in the exception handler concerning the mutex. When the exception is thrown,

83
07:39.020 --> 07:42.980
the destructor is called for the lock_guard and that unlocks the mutex.

84
07:43.440 --> 07:47.600
So the mutex has always been unlocked by the time we get to the catch handler.

85
07:50.620 --> 07:55.240
So there we are again: when it goes out of scope, the destructor is called and the mutex is unlocked without

86
07:55.240 --> 08:01.180
any extra work by the programmer. Which is always good news. If you can get the compiler or the library

87
08:01.180 --> 08:02.030
to do work for you,

88
08:02.050 --> 08:02.970
that is always a good thing.

89
08:04.420 --> 08:10.480
There is just one problem with that, actually, if we go back and look at this again, the mutex is

90
08:10.480 --> 08:12.520
not unlocked until the end of the scope.

91
08:12.790 --> 08:19.630
So this means that we're locking the mutex while we are sleeping. While we have the lock on the

92
08:19.630 --> 08:23.970
mutex no other thread can execute this critical section.

93
08:24.430 --> 08:27.670
So we are basically shutting out all the other threads while we're sleeping.

94
08:28.600 --> 08:35.260
That is one issue with lock_guard. We will look in the next video at another wrapper which solves that problem.

95
08:37.360 --> 08:43.650
In C++17, there is a scoped_lock, which is exactly the same. The only difference is it can lock

96
08:43.660 --> 08:45.540
more than one mutex at the same time.

97
08:46.680 --> 08:51.760
So we can create a scoped_lock and give it several mutexes and it will lock them.

98
08:52.710 --> 08:57.720
You notice that we don't give the template parameter here because this is C++17.

99
08:59.760 --> 09:05.670
The mutexes are always locked in the order that they are given in the constructor call, which is very useful.

100
09:06.990 --> 09:08.210
We will see later on

101
09:08.250 --> 09:13.590
that another way to create deadlock is to have threads locking mutexes in different orders.

102
09:15.080 --> 09:20.570
In the structure, the mutexes will be unlocked and they will be unlocked in the reverse order that

103
09:20.570 --> 09:21.290
they were locked in.

104
09:22.610 --> 09:29.570
So this can avoid a lot of problems that can occur when you are dealing with multiple mutexes. Just

105
09:29.570 --> 09:32.720
one thing to watch out for when you are using scoped_lock.

106
09:33.530 --> 09:38.840
If you are using it with just one mutex argument, it is easy to forget to put the argument in.

107
09:40.280 --> 09:43.430
So we get that which is all perfectly fine, but it does not actually lock anything.

108
09:44.060 --> 09:46.430
So you may get a data race where you were not expecting one.

109
09:48.080 --> 09:49.520
Okay, that's it for this video.

110
09:49.610 --> 09:50.450
I will see you next time.

111
09:50.460 --> 09:52.550
But meanwhile, keep coding!