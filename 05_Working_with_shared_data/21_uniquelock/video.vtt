WEBVTT

0
00:00.210 --> 00:00.810
Hello again.

1
00:01.020 --> 00:09.000
In this video, we are going to look at the unique_lock class. In the last video, we looked at the lock

2
00:09.060 --> 00:09.360
guard.

3
00:10.020 --> 00:17.460
If we create a lock_guard instance, then it will automatically release the look at the end of the scope, even if

4
00:17.460 --> 00:22.350
the function returns due to an exception or a break or an early return.

5
00:24.060 --> 00:28.050
The problem is that the unlock does not occur until the end of the scope.

6
00:28.830 --> 00:35.880
If we have some code which is not critical but is in the same scope, such as this sleep, for example,

7
00:36.150 --> 00:40.080
then the mutex will remain locked while we execute that code.

8
00:40.530 --> 00:44.790
And while this is locked, no other thread can execute the critical region.

9
00:45.240 --> 00:47.850
So we are holding up the rest of the threads.

10
00:49.410 --> 00:54.840
One way to address this: we could put the lock_guard into its own scope within the critical region,

11
00:56.100 --> 01:00.990
and then this code does not get executed until the mutex has been released.

12
01:01.560 --> 01:03.510
So just to prove that that works...

13
01:05.490 --> 01:05.910
Good!

14
01:09.650 --> 01:15.880
When it comes down to the basics, unique_lock and lock_guard do the same thing. The constructor

15
01:15.890 --> 01:20.120
will take a mutex and lock it and the destructor will unlock

16
01:20.120 --> 01:26.990
the mutex. unique_lock also has an unlock() member function so we can call that after the critical region

17
01:27.290 --> 01:30.890
to avoid the problem of blocking other threads while doing non-critical work.

18
01:32.810 --> 01:38.960
If the function returns before calling unlock(), then the unique_lock destructor will ensure that

19
01:38.960 --> 01:40.370
the mutex is unlocked.

20
01:40.790 --> 01:46.280
If it does return normally and we unlock the mutex, then the destructor will check.

21
01:46.820 --> 01:52.460
It will see that the mutex has already been unlocked and it will not unlock it twice, which is a very

22
01:52.460 --> 01:53.200
bad thing to do.

23
01:55.370 --> 01:56.870
So let's see how this works.

24
01:57.320 --> 01:59.780
So we create a unique lock...

25
02:03.130 --> 02:03.620
OK.

26
02:04.420 --> 02:10.450
And then after we execute the critical region, we unlock it. lk dot unlock.

27
02:13.030 --> 02:14.460
So let's see how that works.

28
02:16.040 --> 02:24.540
Yep, there we go. Again, we have no unwanted blocking. So that is what we do, we create the unique_lock

29
02:24.590 --> 02:27.610
instance and then we unlock it after the critical region.

30
02:30.470 --> 02:33.350
unique_lock has more to it than the unlock() member function.

31
02:33.890 --> 02:37.370
There is also quite a variety of different ways in which you can construct it.

32
02:38.750 --> 02:44.840
The way that we constructed just called the lock member function on the mutex, which is the default.

33
02:45.980 --> 02:48.640
You can also try to get the lock, but not wait for it.

34
02:49.920 --> 02:52.300
There are also some options with time outs.

35
02:52.670 --> 02:55.330
You can try to get the lock for a certain amount of time.

36
02:55.850 --> 03:00.290
So if you can not get it within half a second, for the sake of argument, then you give up.

37
03:01.840 --> 03:08.350
You can also wait until a certain point in time, so if it is 11.34 seconds past

38
03:08.350 --> 03:10.940
the minute, you can wait until it is 12 minutes

39
03:10.960 --> 03:11.500
exactly.

40
03:12.820 --> 03:18.270
You can even not lock the mutex at all, which presumably means that you want to lock it later on.

41
03:19.740 --> 03:25.260
In effect, you can also have move semantics, the caller can give you a mutex that is already locked

42
03:25.560 --> 03:28.980
and you acquire ownership of that lock on the mutex.

43
03:31.260 --> 03:36.740
There are some second arguments we can give to the constructor for this. The defer_lock argument

44
03:36.930 --> 03:40.100
will prevent the mutex from being locked immediately.

45
03:41.750 --> 03:43.430
We can call lock() later on.

46
03:44.630 --> 03:49.640
We can also call the global lock() function with the unique lock instance as an argument.

47
03:51.320 --> 03:58.100
If we pass the adopt_lock argument, then the object will take ownership of a mutex that is already

48
03:58.100 --> 03:58.490
locked.

49
04:00.090 --> 04:06.030
As with double unlocking, double locking is very bad unless you have a recursive mutex, which we will

50
04:06.090 --> 04:07.400
look at a bit later.

51
04:09.210 --> 04:15.900
And try_lock will call the try_lock member function instead of lock. You may be wondering with

52
04:15.900 --> 04:20.040
these versions that do not lock the mutex immediately, how does that work?

53
04:21.000 --> 04:22.660
How do you know if it has been locked or not?

54
04:23.430 --> 04:29.610
The answer is that there's a member function owns_lock() and you can call that later on to check if the mutex

55
04:30.150 --> 04:31.050
has been locked.

56
04:35.450 --> 04:42.200
As with many of the classes in the concurrency library, unique_lock instances cannot be copied, but

57
04:42.200 --> 04:48.800
they can be moved. So we can get a lock on a mutex and transfer it to a different unique_lock instance.

58
04:50.250 --> 04:52.680
Although that can only be done within the same thread.

59
04:54.680 --> 05:00.680
This gives us the opportunity of writing something which follows the factory design pattern. We can

60
05:00.680 --> 05:07.400
write a function which creates a lock and returns it, and the type of lock that it will create will depend

61
05:07.430 --> 05:08.270
on its arguments.

62
05:09.970 --> 05:12.550
So we could have locks on different types of mutex.

63
05:13.580 --> 05:15.510
Or we could have different types of look.

64
05:17.530 --> 05:24.370
The caller of the function will now own that lock and will be responsible for unlocking it, or they

65
05:24.370 --> 05:26.310
can just let it go out of scope.

66
05:29.960 --> 05:35.000
So we now know about quite a few different lock objects.
Which one of these should we use?

67
05:35.930 --> 05:39.500
Well, unique_lock is the most powerful, but it has the most overhead.

68
05:40.370 --> 05:45.290
So I would recommend using the lock_guard if you just want to lock a single

69
05:45.290 --> 05:47.000
mutex to the end of the scope.

70
05:48.270 --> 05:53.520
If you want to lock more than one mutex to the end of the scope, then use scoped_lock.

71
05:56.040 --> 06:01.530
Only use unique_lock if you need the extra features or if you need to unlock within the scope.

72
06:03.400 --> 06:09.430
OK, so that's it for this video. Next time, I think, we are going to learn more about mutexes, but until

73
06:09.430 --> 06:10.990
then, keep coding!