WEBVTT

0
00:00.150 --> 00:08.490
Hello again! In this video, we are going to talk about lazy initialization. The usual advice is to initialize

1
00:08.490 --> 00:13.820
variables at the point where they are declared. This is known as "eager" initialization.

2
00:14.370 --> 00:19.230
It is a good practice because for built-in types, it ensures they have a defined value.

3
00:19.560 --> 00:23.540
And for class types, it ensures that they are properly set up and ready for use.

4
00:24.240 --> 00:30.210
So there is no danger that we might accidentally use a variable that is not a well defined state.

5
00:32.300 --> 00:38.030
However, there is an alternative, "lazy" initialization.
This means that a variable is not initialized

6
00:38.030 --> 00:39.990
until the first time it is used.

7
00:40.970 --> 00:47.840
This is mainly used when there is quite a bit of overhead involved in creating or initializing the variable.

8
00:49.040 --> 00:53.600
For example, if we need to get data from a database or set up a network connection.

9
00:55.350 --> 01:01.710
If they are paths through the program in which the variable is not used or if it is not actually convenient

10
01:01.710 --> 01:07.920
to have that overhead at the point where it is declared, then you can declare it uninitialized and

11
01:07.920 --> 01:08.990
initialize it later.

12
01:11.570 --> 01:14.160
This is the traditional way to do it in C++.

13
01:14.960 --> 01:18.630
We have a class of some type, it does not really matter what it does.

14
01:19.760 --> 01:25.410
We have a global variable, which is a pointer to some instance of this class.

15
01:26.870 --> 01:31.100
We give it the initial value null, to indicate that it has not been initialized.

16
01:33.070 --> 01:38.530
And then before we use it, we check whether it has been initialized. If it is the first time and it is

17
01:38.530 --> 01:45.580
not initialized then we initialize it. And then, once we know that it is safe to use it, we can do something

18
01:45.580 --> 01:45.960
with it.

19
01:47.660 --> 01:53.150
And this works fine in single threaded programs, but is it safe in multithreaded programs?

20
01:55.880 --> 01:59.180
Well, I hope you considered the possibility of a data race.

21
02:01.550 --> 02:07.730
So we have multiple threads which will access this, because they all need to check this value, and we

22
02:07.730 --> 02:12.850
have threads which may modify them because one thread will need to write to the variable.

23
02:13.910 --> 02:16.450
So we do have the potential for a data race.

24
02:17.780 --> 02:20.330
So let's fix that by putting a mutex in.

25
02:23.230 --> 02:30.820
So there we are, we have a mutex instance here and then we lock the mutex before we do the check.

26
02:33.330 --> 02:38.790
And then once we get past the critical region in which we have potential conflict, then we unlock the

27
02:38.790 --> 02:41.950
mutex. And that will work perfectly well.

28
02:42.420 --> 02:45.070
But again, this might remind you of something.

29
02:45.630 --> 02:49.740
This is the situation where we had multiple readers and few writers.

30
02:50.940 --> 02:56.010
In this case, we only have one writer, which is the first thread that calls this.

31
02:57.090 --> 03:00.920
So we need to lock the threads to prevent that thread from being interrupted.

32
03:01.140 --> 03:06.090
But once the value has been initialized and we are just reading it, we do not need to lock it again.

33
03:06.840 --> 03:12.510
So all these mutex lock() and unlock() calls are actually a waste of time once we get past that first

34
03:12.510 --> 03:13.410
initialization.

35
03:16.380 --> 03:22.440
The problem here is that we are going to all this trouble with lazy initialization to avoid unnecessary

36
03:22.440 --> 03:25.730
overhead when we initialize this variable at some time.

37
03:26.280 --> 03:29.220
But then we add lots more unnecessary overhead with all this locking.

38
03:32.010 --> 03:36.760
The next attempt is that we only look the mutex if we need to.

39
03:37.140 --> 03:43.410
So first we check the pointer, then we lock the mutex if we need to and initialize it.

40
03:43.680 --> 03:46.740
Otherwise, we jump straight to the use of the variable.

41
03:48.530 --> 03:53.810
So that means we only lock the mutex the first time when the value is being written to.

42
03:54.650 --> 03:56.240
So is this thread-safe?

43
03:58.880 --> 04:00.390
Well, no, still not quite.

44
04:00.410 --> 04:08.810
We still have a data race. It is possible that the first thread can check ptr and then get interrupted,

45
04:10.670 --> 04:13.160
and then another thread runs. It checks the pointer.

46
04:13.490 --> 04:16.490
It gets the lock, initializes and releases the lock.

47
04:18.590 --> 04:23.170
Then the first thread runs again, gets the lock and initializes the pointer again.

48
04:23.420 --> 04:27.800
So we have initialized it twice, which is not what we intended to do.

49
04:30.430 --> 04:34.860
So what we can do then is to check the pointer a second time.

50
04:37.800 --> 04:42.640
This check is inside the lock, so we are the only thread that can be doing this check.

51
04:44.760 --> 04:49.860
So if some other thread has come along and initialized the pointer in between these two statements,

52
04:50.310 --> 04:57.420
then when we check it here, the test will fail and we do not create a second variable.

53
04:58.890 --> 05:00.780
OK, so is this thread-safe?

54
05:03.800 --> 05:07.000
And the answer, believe it or not, is that it is not thread-safe.

55
05:07.580 --> 05:14.510
You may recall that when we were talking about the Singleton, I said there are actually two race conditions

56
05:14.810 --> 05:16.010
and this is where it comes in.

57
05:18.990 --> 05:26.640
The problem is that this is actually three separate operations, so let's try and find out what is going

58
05:26.640 --> 05:27.080
on here.

59
05:29.110 --> 05:34.870
When we call the new operator to create a variable on the heap, there are actually three separate things

60
05:34.870 --> 05:35.380
that happen.

61
05:36.040 --> 05:43.540
The first one is that we allocate the money on the heap and the program will make sure there is enough

62
05:43.540 --> 05:45.890
memory for the object to be stored there.

63
05:47.140 --> 05:52.020
Then we need to create an object in that memory, which is calling the constructor.

64
05:53.050 --> 05:57.030
And then finally, we need to save the address of this memory that has been allocated.

65
05:58.510 --> 06:04.450
So you may expect that they are done in that order, that the allocation is done first, then the constructor call

66
06:04.750 --> 06:06.190
and then the store of the address.

67
06:07.480 --> 06:13.510
Unfortunately, however, C++ allows lots of scope for reordering operations and this is one of the

68
06:13.510 --> 06:15.030
situations where it allows it.

69
06:15.940 --> 06:21.040
So it is quite possible that the program could allocate the memory and then save the address of that

70
06:21.040 --> 06:25.090
memory and then go back and construct the object in this memory.

71
06:28.330 --> 06:35.090
It is possible that the thread could be interrupted between these two operations, so the value of ptr

72
06:35.110 --> 06:40.960
has been set, it is no longer null. Any other thread that checks that will think that the initialization

73
06:40.960 --> 06:41.530
has been done.

74
06:42.580 --> 06:45.100
However, the constructor call has not yet been done.

75
06:46.340 --> 06:51.640
And then when the second thread goes ahead and accesses that memory, it will access an object that has

76
06:51.640 --> 06:54.910
not been constructed and that will be very bad.

77
06:58.350 --> 07:04.170
So we have a threat A, which is going through these steps. It is allocated the memory and it gets suspended.

78
07:06.810 --> 07:14.400
So ptr has been set, but the memory does not contain any actual data. Then a thread B calls this function.

79
07:14.910 --> 07:19.020
It tests the ptr to see whether it needs to acquire a lock.

80
07:20.190 --> 07:22.250
Then it will see that ptr is not null

81
07:22.260 --> 07:26.730
it will not try to get a look, it will jump straight to the call.

82
07:28.650 --> 07:34.100
And then it is going to call a member function of an unconstructed object, and that is undefined behaviour.

83
07:37.950 --> 07:43.470
So the problem is that thread A could come through here and it gets as far as this and then gets

84
07:43.470 --> 07:47.640
suspended, when it has set ptr, but it has not created the object.

85
07:49.080 --> 07:57.120
Then a second thread runs, it checks ptr, ptr is not null, so it jumps straight to this function call

86
07:57.540 --> 08:02.070
even though ptr does not contain a properly constructed object.

87
08:04.870 --> 08:11.980
By the way, this is known as double-checked locking. This is a very popular algorithm, but it does not work,

88
08:11.980 --> 08:14.100
at least not the way that it has been written here.

89
08:16.700 --> 08:18.590
There are various ways to address this.

90
08:18.890 --> 08:24.020
One is to use a function called call_once, which does what the name suggests.

91
08:24.530 --> 08:27.110
It ensures that a function is only called once.

92
08:28.010 --> 08:33.770
It also guarantees that it is done in one thread and the thread that is doing the call cannot be interrupted

93
08:33.770 --> 08:35.480
until the function call has completed.

94
08:36.890 --> 08:44.030
To use that, we need to create a global instance of a once_flag variable, and then we pass that instance

95
08:44.300 --> 08:48.380
and the function that wants to be called, to call_once.

96
08:50.210 --> 08:51.110
So it will look like this.

97
08:51.110 --> 08:58.210
We have our once_flag. This flag is used by the program to store synchronization data.

98
08:58.640 --> 09:00.830
So there is quite a lot going on behind the scenes.

99
09:03.040 --> 09:10.120
And then we call the function call_once, we pass this once_flag as the first argument and then, as

100
09:10.120 --> 09:13.410
the second argument, we pass the function that we want to have called.

101
09:13.720 --> 09:19.750
In this case, we just want to execute the call to new(), which sets the value of the ptr.

102
09:22.650 --> 09:28.950
So this double-checked looking with call_once, is thread-safe, but it has less overhead than using a mutex.

103
09:30.510 --> 09:35.220
There is actually another way of doing this, if you think back to the Singleton, then we solved that

104
09:35.220 --> 09:37.590
by using a static variable.

105
09:38.520 --> 09:45.630
And finally, just to confuse things even more, C++17 specified the order in which the operations

106
09:45.630 --> 09:47.400
are performed in a [call to] new().

107
09:48.960 --> 09:54.300
So the allocation is always done first, then the construction of the object and then storing the address

108
09:54.300 --> 09:55.010
of the memory.

109
09:55.380 --> 10:00.580
So there's no longer a race condition in the classic implementation of double-checked looking.

110
10:01.770 --> 10:09.060
So we now have four ways to do lazy initialization in a thread-safe way. We can use the mutex as we did

111
10:09.060 --> 10:09.600
at the beginning,

112
10:09.610 --> 10:14.010
if we are not worried about the overhead. We can use this call_once

113
10:14.010 --> 10:18.390
function to make sure the initialization code only gets called once.

114
10:19.410 --> 10:27.510
We can use the classic double-checked locking algorithm with a compiler that supports C++17, and finally

115
10:27.510 --> 10:31.850
we can make this a static local variable provided we do not need it anywhere else.

116
10:34.390 --> 10:36.310
OK, so that's it for this video.

117
10:36.760 --> 10:39.940
I'll see you later, but meanwhile, keep coding!