1
00:00:00,180 --> 00:00:00,720
Hello again.

2
00:00:01,020 --> 00:00:08,340
In this video, we are going to look at shared data initialization. There are various ways we can create

3
00:00:08,340 --> 00:00:09,210
shared data.

4
00:00:09,600 --> 00:00:15,960
We could use a global variable or a static variable, which is declared in the namespace scope.

5
00:00:16,710 --> 00:00:22,920
And that could be shared by all the threads in the program, including main(). We could have a class member

6
00:00:22,920 --> 00:00:29,420
which is declared static and that is potentially shared by all threads which execute a member function

7
00:00:29,430 --> 00:00:30,180
of the class.

8
00:00:31,550 --> 00:00:36,980
And then finally, we can have a local variable in a task function and we declare that variable static.

9
00:00:37,760 --> 00:00:41,480
And this is shared by all threads which execute that function.

10
00:00:43,960 --> 00:00:46,660
There are actually two different rules for initialization.

11
00:00:47,170 --> 00:00:53,440
One is for local variables, which we will look at in a minute, but for everything else, the variable is initialized

12
00:00:53,710 --> 00:00:54,980
when the program starts up.

13
00:00:55,870 --> 00:01:00,450
And at that point, there is only going to be one thread running. main() has not even been called yet.

14
00:01:00,940 --> 00:01:04,600
So there cannot be a data race because there are not any conflicting threads.

15
00:01:08,640 --> 00:01:16,080
When we have a local variable, so we have a function with a static local variable, C++ says this variable

16
00:01:16,410 --> 00:01:20,520
will be initialized the first time that the program executes this code.

17
00:01:21,360 --> 00:01:24,030
And in a single threaded program, that is all very straightforward.

18
00:01:24,390 --> 00:01:26,100
But what happens when we have threads?

19
00:01:27,120 --> 00:01:32,520
I would like you to pause the video for a moment and think about whether there could be any issues with

20
00:01:32,520 --> 00:01:32,850
this.

21
00:01:38,250 --> 00:01:41,610
Just in case you have forgotten, here is the definition of a data race.

22
00:01:42,740 --> 00:01:44,870
So we have potentially conflicting accesses.

23
00:01:46,150 --> 00:01:52,090
We could have multiple threads accessing the shared local variable, and one or more of these threads could

24
00:01:52,090 --> 00:01:53,410
be trying to initialize it.

25
00:01:55,360 --> 00:02:01,750
So we have the usual potential for a data race. But do we actually get one?

26
00:02:03,670 --> 00:02:09,460
In older versions of C++, there was no acknowledgement of the existence of threads, so the behaviour

27
00:02:09,460 --> 00:02:10,300
was undefined.

28
00:02:12,070 --> 00:02:19,980
In C++11, it actually specifies that only one thread can perform the initialization. If any other thread

29
00:02:20,080 --> 00:02:25,210
tries to access the local variable while it is being initialized, it will be blocked until the first thread

30
00:02:25,210 --> 00:02:26,770
has finished initializing it.

31
00:02:27,670 --> 00:02:34,870
So this means that the initialization "happens before" any other access and therefore we do not get a data race.

32
00:02:36,190 --> 00:02:39,010
Obviously, that only applies when we are initializing the variable.

33
00:02:39,430 --> 00:02:44,650
If we modify it later on, then it is exactly the same as any other type of variable.

34
00:02:45,400 --> 00:02:47,770
And we need to protect against a data race.

35
00:02:51,250 --> 00:02:56,970
Moving away from built in types, a more interesting example of shared data is the Singleton class.

36
00:02:58,180 --> 00:03:04,240
There is a famous book about design patterns, and if you ask people for an example of a design pattern,

37
00:03:04,660 --> 00:03:08,800
they will say Singleton, even if they have never read the book or heard of any other design pattern.

38
00:03:10,520 --> 00:03:15,590
A singleton is a class that is written in such a way that there can only be one global instance of it in the

39
00:03:15,590 --> 00:03:21,030
program. You would use this if you need to have only one instance of something.

40
00:03:21,350 --> 00:03:26,750
For example, if you have a class that writes to an audit trail, there is no point having different

41
00:03:26,750 --> 00:03:28,760
instances writing to the same log file.

42
00:03:29,120 --> 00:03:30,570
That just complicates things.

43
00:03:32,930 --> 00:03:38,930
You would implement a Singleton class in C++ by deleting the copy and move operators, so that prevents

44
00:03:38,930 --> 00:03:46,520
the program from creating a new instance and then you provide a global function which returns the instance

45
00:03:46,520 --> 00:03:47,060
of the class.

46
00:03:49,040 --> 00:03:51,860
This will check if the instance already exists.

47
00:03:52,190 --> 00:03:55,460
If it does not exist, it will create it and initialize it and then return it.

48
00:03:56,210 --> 00:03:58,640
If it already exists, then it just returns it.

49
00:04:00,650 --> 00:04:04,450
So this is a classic 1990s style implementation of a singleton.

50
00:04:05,330 --> 00:04:07,480
We have the class that is defined somewhere.

51
00:04:08,360 --> 00:04:12,680
We have a global variable, which is a pointer to the Singleton instance.

52
00:04:14,590 --> 00:04:20,580
And we initialize this with the null pointer to indicate that it is not pointing to a valid Singleton

53
00:04:20,590 --> 00:04:21,110
instance.

54
00:04:22,450 --> 00:04:24,220
This is a global variable.

55
00:04:24,340 --> 00:04:28,980
So it's going to be initialized at runtime before any separate threads are started.

56
00:04:30,220 --> 00:04:34,080
So there are no issues about data races with this assignment here.

57
00:04:36,090 --> 00:04:39,430
Then we have a function which returns a pointer to the singleton.

58
00:04:41,300 --> 00:04:44,780
This will check if the instance has been initialized.

59
00:04:46,040 --> 00:04:52,040
If the variable single is equal to null pointer, then the instance has not been initialized, so it will

60
00:04:52,040 --> 00:04:58,730
create it and return it and initialize it, otherwise it will just return it straightaway.

61
00:05:00,190 --> 00:05:06,340
And if you have a single threaded program, it all works perfectly. However, if we have multiple threads,

62
00:05:06,580 --> 00:05:12,550
then there is a data race and I would like you to pause the video again and try and work out where the

63
00:05:12,550 --> 00:05:13,390
data race is.

64
00:05:17,590 --> 00:05:18,790
OK, did you find it?

65
00:05:19,990 --> 00:05:23,980
There are actually two data races in here, but the second one is rather subtle.

66
00:05:24,370 --> 00:05:26,280
We will talk about it in another video.

67
00:05:26,770 --> 00:05:30,400
But if you spotted that one as well, then put a gold star on your screen!

68
00:05:34,550 --> 00:05:39,650
The race condition is in here. If we have multiple threads calling this function, then we have multiple threads

69
00:05:39,650 --> 00:05:44,240
which are accessing "single" and the possibility that threads are modifying "single".

70
00:05:46,930 --> 00:05:50,410
I have actually spared you the data race [definition]. I hope it's still fresh from the last time!

71
00:05:52,450 --> 00:05:59,380
So what can we do about this? As it happens, the guarantees about initializing static local variables

72
00:05:59,380 --> 00:06:05,770
in C++11 mean that it's very straightforward to write a function that returns a Singleton instance.

73
00:06:07,660 --> 00:06:08,230
This is it.

74
00:06:08,380 --> 00:06:09,170
Yes, all of it!

75
00:06:10,420 --> 00:06:12,460
We don't have the global pointer anymore.

76
00:06:13,120 --> 00:06:17,460
We just have a static instance, which is a local variable in the Singleton function.

77
00:06:18,190 --> 00:06:21,520
And then instead of returning a pointer, we return a reference to it.

78
00:06:23,790 --> 00:06:24,890
So how does this work?

79
00:06:27,210 --> 00:06:34,200
The rules for initializing local static variables say that the first thread to execute this code will

80
00:06:34,200 --> 00:06:38,590
initialize it and it cannot be interrupted until it has finished the initialization.

81
00:06:39,510 --> 00:06:44,280
So by the time another thread runs, this single variable has already been initialized.

82
00:06:45,520 --> 00:06:51,070
So the first time through, it is going to initialize this variable and return it. The second time through, it is just

83
00:06:51,070 --> 00:06:52,150
going to return it.

84
00:06:55,500 --> 00:07:03,060
So here is a Singleton instance. It is just a very trivial class.
I have deleted the copy constructor,

85
00:07:03,360 --> 00:07:07,950
copy assignment operator, move constructor and move assignment operator.

86
00:07:09,990 --> 00:07:15,500
These have private access, so in fact, they do not actually need to be deleted. Because they are private,

87
00:07:15,510 --> 00:07:21,920
they cannot be called from outside the class. But putting equals delete means it is obvious that I

88
00:07:21,930 --> 00:07:24,390
want these functions never to be called.

89
00:07:25,550 --> 00:07:27,680
This, by the way, is a C++11 feature.

90
00:07:29,910 --> 00:07:35,220
I have got a constructor, which is just a trivial one. It will print something out, so we can see if the

91
00:07:35,220 --> 00:07:36,300
constructor has been called.

92
00:07:37,840 --> 00:07:42,430
I also have a forward declaration for the function to get the Singleton instance.

93
00:07:46,060 --> 00:07:49,000
That function is just the same as the one on the slide.

94
00:07:51,540 --> 00:07:57,150
Then there is a main function. It starts up some threads.
The task function for the threads will just

95
00:07:57,150 --> 00:08:02,670
call get_singleton() and then we are going to print out the address of this instance, which is returned

96
00:08:02,670 --> 00:08:06,300
by the function,
so we can see whether it really is the same object.

97
00:08:08,110 --> 00:08:09,670
OK, let's try that out.

98
00:08:11,290 --> 00:08:18,220
So there we are, we get the constructor output once, so that looks as though the object has only

99
00:08:18,220 --> 00:08:22,120
been created once,
and we get the same address.

100
00:08:23,000 --> 00:08:27,760
(Obviously, we get the interleaving because the output hasn't been protected by a mutex)

101
00:08:30,320 --> 00:08:33,260
Let's just run it once again, that is a slightly nicer version.

102
00:08:35,010 --> 00:08:36,710
OK, so that is it for this video.

103
00:08:37,220 --> 00:08:38,140
I will see you next time.

104
00:08:38,150 --> 00:08:40,460
But meanwhile, keep coding!

