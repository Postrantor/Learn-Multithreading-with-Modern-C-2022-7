WEBVTT

0
00:00.180 --> 00:00.700
Hello there.

1
00:00.990 --> 00:07.110
In this video, we are going to look at deadlock. We have mentioned deadlock a few times, so let's try

2
00:07.110 --> 00:09.090
and find out exactly what we mean by it.

3
00:11.780 --> 00:15.680
We say that a thread is deadlocked when it cannot run at all.

4
00:17.300 --> 00:22.580
There are times when a thread gets interrupted and it cannot run, but then it will wake up again

5
00:22.580 --> 00:24.050
and it should be able to run.

6
00:24.470 --> 00:26.840
If a thread is deadlocked, it cannot run at all.

7
00:26.850 --> 00:27.890
It is completely stuck.

8
00:29.920 --> 00:33.780
Deadlock often occurs when we have two or more threads waiting for each other.

9
00:36.230 --> 00:41.630
We have a thread A which is waiting for some other thread B to do something or to finish doing something,

10
00:41.840 --> 00:45.170
but B cannot finish until it gets something from A.

11
00:45.380 --> 00:49.930
But B cannot get anything from A because A is not running, because it is waiting for B.

12
00:50.360 --> 00:53.650
So threads A and B are stuck waiting for each other.

13
00:54.200 --> 00:56.380
They are both waiting for something which will never happen.

14
00:58.100 --> 01:01.820
The classic way to demonstrate this is waiting for locks on mutexes.

15
01:01.820 --> 01:08.270
But there are other situations in which threads can be deadlocked. If thread A is waiting for the results

16
01:08.270 --> 01:15.080
of some computation that thread B is doing. If it is waiting for a message to be sent by thread B.

17
01:16.380 --> 01:20.430
Or it could be waiting for thread B to produce some sort of GUI event.

18
01:24.310 --> 01:28.730
The simplest way to get a deadlock is to have two threads trying to look the same

19
01:28.750 --> 01:30.690
mutexes in different orders.

20
01:31.510 --> 01:38.560
So we have the first thread, which looks mutex number one, and the second thread looks mutex number two.

21
01:40.060 --> 01:45.640
Then this thread wants to lock mutex number two, but it has to wait because that is already locked by

22
01:45.640 --> 01:46.320
thread two.

23
01:47.500 --> 01:54.220
Meanwhile, thread two is waiting for a lock on mutex one, which is locked at by thread one.

24
01:55.180 --> 02:02.260
So thread two cannot run until thread one releases the lock and thread one cannot run until thread 

25
02:02.270 --> 02:03.460
two releases the lock.

26
02:03.730 --> 02:07.180
So both these threads are stuck waiting for a lock on the mutex.

27
02:10.080 --> 02:16.950
The code would look like this, so thread one's function will get a lock on mutex one, then try to

28
02:16.950 --> 02:18.120
get a lock on mutex two.

29
02:19.400 --> 02:27.890
The other thread will get a lock on mutex number two, then it tries to get a lock on mutex number one. So once

30
02:27.890 --> 02:33.890
this thread gets the look on mutex number two, it will exit and release the lock on one, which would

31
02:33.890 --> 02:34.940
allow thread two to run.

32
02:35.330 --> 02:37.970
But it cannot run yet because the lock has not been released.

33
02:39.560 --> 02:44.300
But thread two cannot run yet because it is waiting for the lock on mutex one.

34
02:49.110 --> 02:58.290
So here is the code with some debug information added. So we get the lock on mutex one and then we try

35
02:58.290 --> 02:59.640
to get the look on mutex two.

36
03:03.130 --> 03:08.530
In the other thread function, we get the lock on mutex two, then we try to get the lock on mutex

37
03:08.530 --> 03:12.310
one. And there is a main function, which does nothing very exciting.

38
03:15.130 --> 03:17.160
Okay, so let's see how that works.

39
03:20.870 --> 03:30.050
So thread 1 and thread 2 are both trying to lock their mutexes, thread 2 locks mutex number two and thread 1 looks mutex number one, and

40
03:30.050 --> 03:32.230
then they try to lock the other thread's mutex.

41
03:32.720 --> 03:38.940
So thread one is waiting for a lock on mutex two, which is already locked by thread two and thread

42
03:38.960 --> 03:43.310
two is waiting for a lock on mutex one, which is already locked by third one.

43
03:44.810 --> 03:46.750
So the program is completely deadlocked.

44
03:46.760 --> 03:48.110
You can see nothing is happening.

45
03:49.010 --> 03:51.580
I have to press control-C to get out of it.

46
03:56.330 --> 04:00.130
Now, if we change this, so the the threads get the mutexes in the same order...

47
04:13.540 --> 04:15.010
Let's see what difference that makes.

48
04:17.900 --> 04:20.720
So there we are, the program has actually run and completed.

49
04:22.470 --> 04:28.690
So both sides are trying to lock mutex number one. Thread two gets there first, locks mutex one then

50
04:28.720 --> 04:35.880
it tries to lock mutex two, then it reaches the end of the thread function and it releases all the locks. Then thread one

51
04:35.880 --> 04:37.170
can lock mutex number one.

52
04:37.500 --> 04:39.030
Then it tries to lock mutex two.

53
04:39.870 --> 04:40.980
There is no one holding a lock in it.

54
04:40.980 --> 04:43.260
So it can do that and then that can run to completion.

55
04:43.620 --> 04:45.930
And then the entire program finishes normally.

56
04:50.630 --> 04:53.560
So here are some guidelines on how to avoid deadlock.

57
04:54.410 --> 05:00.980
The basic rule is never wait for a thread if there is any chance it could be waiting for your thread

58
05:00.980 --> 05:01.700
at some point.

59
05:02.930 --> 05:08.750
And it may not just be a simple two thread situation where A waits for B and B waits for A, you could

60
05:08.750 --> 05:12.830
have cycles where A waits for B, B waits for C, and C waits for A.

61
05:15.150 --> 05:21.300
Avoid nested locks. If your thread already has a lock, do not acquire another one, even if it is on a

62
05:21.300 --> 05:22.050
different mutex.

63
05:22.890 --> 05:26.460
If you need multiple locks, acquire them in a single operation.

64
05:26.760 --> 05:28.160
I will show you how to do that in a minute.

65
05:30.030 --> 05:35.010
If you do need multiple locks and you cannot acquire them in a single operation, then acquire them in

66
05:35.010 --> 05:36.390
the same order in every thread.

67
05:37.170 --> 05:40.530
So that was how I avoided deadlock in the code

68
05:40.530 --> 05:44.030
just then. I made sure that the threads acquire the locks in the same order.

69
05:47.560 --> 05:52.570
Another piece of advice: do not call code within a critical section unless you know exactly what it

70
05:52.570 --> 05:52.900
does.

71
05:54.070 --> 05:58.030
I mean, these are all basically code that could do anything and you do not have control over [them].

72
05:59.590 --> 06:06.400
These are all types of code in which other people can add locks without you knowing about it, and if

73
06:06.400 --> 06:10.750
you do not know where the locks are, you do not know what order the locks are going to be taken in, in

74
06:10.750 --> 06:11.410
different threads.

75
06:13.770 --> 06:19.200
However, if you do know that the code does not take locks and you know it is not going to be changed,

76
06:19.350 --> 06:20.360
then that is okay.

77
06:24.740 --> 06:29.550
Yes, so as we said, we acquire the locks in the same order, but that's not always ideal.

78
06:29.840 --> 06:31.820
It does rely on the programmer to get it right.

79
06:32.900 --> 06:35.590
In a simple example like that one, it is not difficult.

80
06:35.600 --> 06:40.760
But if you have a large program, you may easily lose track of where the locks are taken.

81
06:41.030 --> 06:42.860
This is not really a viable strategy.

82
06:46.460 --> 06:52.160
A better option is to use the features provided by the C++ library, which will allow you to lock both

83
06:52.160 --> 06:58.040
mutexes at the same time. In C++17, we can use a scoped_lock.

84
06:58.910 --> 07:05.480
So we just have a scoped_lock, which will try to lock both the mutexes in a single call.

85
07:05.870 --> 07:07.730
And it does not matter what order you put them in.

86
07:09.110 --> 07:12.950
This will either lock both mutexes or not lock either of them.

87
07:16.460 --> 07:24.200
So here is that code with a bit more debugging information and some sleeps added. So we have a thread that

88
07:24.470 --> 07:29.260
calls scoped_lock and another thread that calls scoped_lock with the mutexes in a different order.

89
07:31.600 --> 07:33.890
Again, the same boring main function.

90
07:38.060 --> 07:45.440
So this looks OK, both the threads try to look the mutexes, thread two gets there first, then it will

91
07:45.440 --> 07:49.490
do some work, then it will exit, which will release the mutexes.

92
07:50.210 --> 07:52.670
Then thread one will lock both mutexes.

93
07:53.120 --> 07:54.820
It will do some work and it will exit.

94
07:55.550 --> 07:57.020
So this all works normally.

95
08:02.080 --> 08:11.440
If you are using C++11 or 14, you can use the lock function to lock both mutexes and then we create

96
08:11.440 --> 08:14.860
unique_lock instances which will adapt those mutexes.

97
08:16.030 --> 08:18.760
So these are just ordinary mutexes which happen to be locked.

98
08:18.790 --> 08:20.080
These objects are unique_lock objects

99
08:20.080 --> 08:26.050
which will acquire ownership of the lock on the mutex, and we can either manually unlock them

100
08:26.050 --> 08:28.030
or else they will go out of scope,

101
08:28.030 --> 08:31.720
and that will cause the lock to be released by the destructor call.

102
08:33.720 --> 08:39.120
There seem to be a lot of alternative ways of doing things with mutexes, so you can also create

103
08:39.120 --> 08:43.680
the locks first with the defer_lock argument and then do the call later.

104
08:45.190 --> 08:51.490
So we have the unique_lock objects which own a lock on the mutexes, but the mutexes do not actually

105
08:51.490 --> 08:52.690
get locked until later on.

106
08:58.400 --> 09:01.550
So, again, I put some debugging information into the code.

107
09:03.520 --> 09:10.780
So we have the lock() call, then we have the unique look with adopt_lock.

108
09:13.490 --> 09:16.900
Thread two is the same with the mutexes in the reverse order.

109
09:19.390 --> 09:20.910
So this works more or less the same.

110
09:21.160 --> 09:25.150
The threads try to lock their mutexes, thread 2 gets there first.

111
09:25.150 --> 09:32.050
It locks the mutexes, it does some work and then it exits, which releases the mutexes when the destructors

112
09:32.050 --> 09:33.970
are called on the unique lock objects.

113
09:34.300 --> 09:39.940
And then thread one can get the locks and do some work and release the mutexes when it goes out of scope.

114
09:45.760 --> 09:50.740
There are some cases where it is not possible to acquire multiple locks simultaneously because of the

115
09:50.740 --> 09:51.660
nature of the problem.

116
09:53.570 --> 10:00.770
In that case, you impose some kind of ordering. For example, you could say that a thread cannot lock a resource,

117
10:01.280 --> 10:06.680
unless it has already locked something which has a lower identifier and for the identifier, you could

118
10:06.680 --> 10:09.140
use names or numbers.

119
10:12.120 --> 10:18.750
The book that I recommend by Anthony Williams, it has the code for a hierarchical mutex that will

120
10:18.750 --> 10:19.470
implement this.

121
10:20.780 --> 10:24.330
I have also got a simpler example of that in the workshop for this section.

122
10:25.810 --> 10:31.390
So when you get to the end of the section and get stuck into the workshop, you will be able to do that

123
10:31.390 --> 10:31.980
for yourself.

124
10:36.700 --> 10:42.040
Deadlock is not just about looking mutexes. As we saw earlier, there are some situations, such as waiting

125
10:42.040 --> 10:44.160
for GUI events, where deadlock can occur.

126
10:44.680 --> 10:49.480
Generally, it is any situation where threads are waiting for each other, which does not necessarily

127
10:49.480 --> 10:51.060
require a lock on a mutex.

128
10:51.460 --> 10:54.520
It can also happen if the threads are calling join() on each other.

129
10:55.510 --> 11:00.190
And it can also happen if the threads are just stopping and waiting, which we will see how to do later

130
11:00.190 --> 11:00.380
on.

131
11:01.510 --> 11:07.630
So if you hold a lock, do not wait for another thread, because that thread may need the lock before

132
11:07.630 --> 11:12.340
it can do anything. In general, try to avoid waiting for threads.

133
11:13.530 --> 11:17.310
Because in that case, you will never have a situation where another thread is waiting for your thread.

134
11:18.360 --> 11:25.200
And when you create a thread, if possible, call join() in the same function where you create the

135
11:25.200 --> 11:25.950
thread instance.

136
11:26.970 --> 11:31.890
So, for example, when we create our threads in main(), we should always call join on them in main().

137
11:33.450 --> 11:35.080
OK, so that's it for this video.

138
11:35.520 --> 11:36.420
I'll see you next time.

139
11:36.430 --> 11:38.820
But meanwhile, keep coding!