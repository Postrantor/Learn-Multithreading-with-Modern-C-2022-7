1
00:00:00,180 --> 00:00:00,700
Hello there.

2
00:00:00,990 --> 00:00:07,110
In this video, we are going to look at deadlock. We have mentioned deadlock a few times, so let's try

3
00:00:07,110 --> 00:00:09,090
and find out exactly what we mean by it.

4
00:00:11,780 --> 00:00:15,680
We say that a thread is deadlocked when it cannot run at all.

5
00:00:17,300 --> 00:00:22,580
There are times when a thread gets interrupted and it cannot run, but then it will wake up again

6
00:00:22,580 --> 00:00:24,050
and it should be able to run.

7
00:00:24,470 --> 00:00:26,840
If a thread is deadlocked, it cannot run at all.

8
00:00:26,850 --> 00:00:27,890
It is completely stuck.

9
00:00:29,920 --> 00:00:33,780
Deadlock often occurs when we have two or more threads waiting for each other.

10
00:00:36,230 --> 00:00:41,630
We have a thread A which is waiting for some other thread B to do something or to finish doing something,

11
00:00:41,840 --> 00:00:45,170
but B cannot finish until it gets something from A.

12
00:00:45,380 --> 00:00:49,930
But B cannot get anything from A because A is not running, because it is waiting for B.

13
00:00:50,360 --> 00:00:53,650
So threads A and B are stuck waiting for each other.

14
00:00:54,200 --> 00:00:56,380
They are both waiting for something which will never happen.

15
00:00:58,100 --> 00:01:01,820
The classic way to demonstrate this is waiting for locks on mutexes.

16
00:01:01,820 --> 00:01:08,270
But there are other situations in which threads can be deadlocked. If thread A is waiting for the results

17
00:01:08,270 --> 00:01:15,080
of some computation that thread B is doing. If it is waiting for a message to be sent by thread B.

18
00:01:16,380 --> 00:01:20,430
Or it could be waiting for thread B to produce some sort of GUI event.

19
00:01:24,310 --> 00:01:28,730
The simplest way to get a deadlock is to have two threads trying to look the same

20
00:01:28,750 --> 00:01:30,690
mutexes in different orders.

21
00:01:31,510 --> 00:01:38,560
So we have the first thread, which looks mutex number one, and the second thread looks mutex number two.

22
00:01:40,060 --> 00:01:45,640
Then this thread wants to lock mutex number two, but it has to wait because that is already locked by

23
00:01:45,640 --> 00:01:46,320
thread two.

24
00:01:47,500 --> 00:01:54,220
Meanwhile, thread two is waiting for a lock on mutex one, which is locked at by thread one.

25
00:01:55,180 --> 00:02:02,260
So thread two cannot run until thread one releases the lock and thread one cannot run until thread 

26
00:02:02,270 --> 00:02:03,460
two releases the lock.

27
00:02:03,730 --> 00:02:07,180
So both these threads are stuck waiting for a lock on the mutex.

28
00:02:10,080 --> 00:02:16,950
The code would look like this, so thread one's function will get a lock on mutex one, then try to

29
00:02:16,950 --> 00:02:18,120
get a lock on mutex two.

30
00:02:19,400 --> 00:02:27,890
The other thread will get a lock on mutex number two, then it tries to get a lock on mutex number one. So once

31
00:02:27,890 --> 00:02:33,890
this thread gets the look on mutex number two, it will exit and release the lock on one, which would

32
00:02:33,890 --> 00:02:34,940
allow thread two to run.

33
00:02:35,330 --> 00:02:37,970
But it cannot run yet because the lock has not been released.

34
00:02:39,560 --> 00:02:44,300
But thread two cannot run yet because it is waiting for the lock on mutex one.

35
00:02:49,110 --> 00:02:58,290
So here is the code with some debug information added. So we get the lock on mutex one and then we try

36
00:02:58,290 --> 00:02:59,640
to get the look on mutex two.

37
00:03:03,130 --> 00:03:08,530
In the other thread function, we get the lock on mutex two, then we try to get the lock on mutex

38
00:03:08,530 --> 00:03:12,310
one. And there is a main function, which does nothing very exciting.

39
00:03:15,130 --> 00:03:17,160
Okay, so let's see how that works.

40
00:03:20,870 --> 00:03:30,050
So thread 1 and thread 2 are both trying to lock their mutexes, thread 2 locks mutex number two and thread 1 looks mutex number one, and

41
00:03:30,050 --> 00:03:32,230
then they try to lock the other thread's mutex.

42
00:03:32,720 --> 00:03:38,940
So thread one is waiting for a lock on mutex two, which is already locked by thread two and thread

43
00:03:38,960 --> 00:03:43,310
two is waiting for a lock on mutex one, which is already locked by third one.

44
00:03:44,810 --> 00:03:46,750
So the program is completely deadlocked.

45
00:03:46,760 --> 00:03:48,110
You can see nothing is happening.

46
00:03:49,010 --> 00:03:51,580
I have to press control-C to get out of it.

47
00:03:56,330 --> 00:04:00,130
Now, if we change this, so the the threads get the mutexes in the same order...

48
00:04:13,540 --> 00:04:15,010
Let's see what difference that makes.

49
00:04:17,900 --> 00:04:20,720
So there we are, the program has actually run and completed.

50
00:04:22,470 --> 00:04:28,690
So both sides are trying to lock mutex number one. Thread two gets there first, locks mutex one then

51
00:04:28,720 --> 00:04:35,880
it tries to lock mutex two, then it reaches the end of the thread function and it releases all the locks. Then thread one

52
00:04:35,880 --> 00:04:37,170
can lock mutex number one.

53
00:04:37,500 --> 00:04:39,030
Then it tries to lock mutex two.

54
00:04:39,870 --> 00:04:40,980
There is no one holding a lock in it.

55
00:04:40,980 --> 00:04:43,260
So it can do that and then that can run to completion.

56
00:04:43,620 --> 00:04:45,930
And then the entire program finishes normally.

57
00:04:50,630 --> 00:04:53,560
So here are some guidelines on how to avoid deadlock.

58
00:04:54,410 --> 00:05:00,980
The basic rule is never wait for a thread if there is any chance it could be waiting for your thread

59
00:05:00,980 --> 00:05:01,700
at some point.

60
00:05:02,930 --> 00:05:08,750
And it may not just be a simple two thread situation where A waits for B and B waits for A, you could

61
00:05:08,750 --> 00:05:12,830
have cycles where A waits for B, B waits for C, and C waits for A.

62
00:05:15,150 --> 00:05:21,300
Avoid nested locks. If your thread already has a lock, do not acquire another one, even if it is on a

63
00:05:21,300 --> 00:05:22,050
different mutex.

64
00:05:22,890 --> 00:05:26,460
If you need multiple locks, acquire them in a single operation.

65
00:05:26,760 --> 00:05:28,160
I will show you how to do that in a minute.

66
00:05:30,030 --> 00:05:35,010
If you do need multiple locks and you cannot acquire them in a single operation, then acquire them in

67
00:05:35,010 --> 00:05:36,390
the same order in every thread.

68
00:05:37,170 --> 00:05:40,530
So that was how I avoided deadlock in the code

69
00:05:40,530 --> 00:05:44,030
just then. I made sure that the threads acquire the locks in the same order.

70
00:05:47,560 --> 00:05:52,570
Another piece of advice: do not call code within a critical section unless you know exactly what it

71
00:05:52,570 --> 00:05:52,900
does.

72
00:05:54,070 --> 00:05:58,030
I mean, these are all basically code that could do anything and you do not have control over [them].

73
00:05:59,590 --> 00:06:06,400
These are all types of code in which other people can add locks without you knowing about it, and if

74
00:06:06,400 --> 00:06:10,750
you do not know where the locks are, you do not know what order the locks are going to be taken in, in

75
00:06:10,750 --> 00:06:11,410
different threads.

76
00:06:13,770 --> 00:06:19,200
However, if you do know that the code does not take locks and you know it is not going to be changed,

77
00:06:19,350 --> 00:06:20,360
then that is okay.

78
00:06:24,740 --> 00:06:29,550
Yes, so as we said, we acquire the locks in the same order, but that's not always ideal.

79
00:06:29,840 --> 00:06:31,820
It does rely on the programmer to get it right.

80
00:06:32,900 --> 00:06:35,590
In a simple example like that one, it is not difficult.

81
00:06:35,600 --> 00:06:40,760
But if you have a large program, you may easily lose track of where the locks are taken.

82
00:06:41,030 --> 00:06:42,860
This is not really a viable strategy.

83
00:06:46,460 --> 00:06:52,160
A better option is to use the features provided by the C++ library, which will allow you to lock both

84
00:06:52,160 --> 00:06:58,040
mutexes at the same time. In C++17, we can use a scoped_lock.

85
00:06:58,910 --> 00:07:05,480
So we just have a scoped_lock, which will try to lock both the mutexes in a single call.

86
00:07:05,870 --> 00:07:07,730
And it does not matter what order you put them in.

87
00:07:09,110 --> 00:07:12,950
This will either lock both mutexes or not lock either of them.

88
00:07:16,460 --> 00:07:24,200
So here is that code with a bit more debugging information and some sleeps added. So we have a thread that

89
00:07:24,470 --> 00:07:29,260
calls scoped_lock and another thread that calls scoped_lock with the mutexes in a different order.

90
00:07:31,600 --> 00:07:33,890
Again, the same boring main function.

91
00:07:38,060 --> 00:07:45,440
So this looks OK, both the threads try to look the mutexes, thread two gets there first, then it will

92
00:07:45,440 --> 00:07:49,490
do some work, then it will exit, which will release the mutexes.

93
00:07:50,210 --> 00:07:52,670
Then thread one will lock both mutexes.

94
00:07:53,120 --> 00:07:54,820
It will do some work and it will exit.

95
00:07:55,550 --> 00:07:57,020
So this all works normally.

96
00:08:02,080 --> 00:08:11,440
If you are using C++11 or 14, you can use the lock function to lock both mutexes and then we create

97
00:08:11,440 --> 00:08:14,860
unique_lock instances which will adapt those mutexes.

98
00:08:16,030 --> 00:08:18,760
So these are just ordinary mutexes which happen to be locked.

99
00:08:18,790 --> 00:08:20,080
These objects are unique_lock objects

100
00:08:20,080 --> 00:08:26,050
which will acquire ownership of the lock on the mutex, and we can either manually unlock them

101
00:08:26,050 --> 00:08:28,030
or else they will go out of scope,

102
00:08:28,030 --> 00:08:31,720
and that will cause the lock to be released by the destructor call.

103
00:08:33,720 --> 00:08:39,120
There seem to be a lot of alternative ways of doing things with mutexes, so you can also create

104
00:08:39,120 --> 00:08:43,680
the locks first with the defer_lock argument and then do the call later.

105
00:08:45,190 --> 00:08:51,490
So we have the unique_lock objects which own a lock on the mutexes, but the mutexes do not actually

106
00:08:51,490 --> 00:08:52,690
get locked until later on.

107
00:08:58,400 --> 00:09:01,550
So, again, I put some debugging information into the code.

108
00:09:03,520 --> 00:09:10,780
So we have the lock() call, then we have the unique look with adopt_lock.

109
00:09:13,490 --> 00:09:16,900
Thread two is the same with the mutexes in the reverse order.

110
00:09:19,390 --> 00:09:20,910
So this works more or less the same.

111
00:09:21,160 --> 00:09:25,150
The threads try to lock their mutexes, thread 2 gets there first.

112
00:09:25,150 --> 00:09:32,050
It locks the mutexes, it does some work and then it exits, which releases the mutexes when the destructors

113
00:09:32,050 --> 00:09:33,970
are called on the unique lock objects.

114
00:09:34,300 --> 00:09:39,940
And then thread one can get the locks and do some work and release the mutexes when it goes out of scope.

115
00:09:45,760 --> 00:09:50,740
There are some cases where it is not possible to acquire multiple locks simultaneously because of the

116
00:09:50,740 --> 00:09:51,660
nature of the problem.

117
00:09:53,570 --> 00:10:00,770
In that case, you impose some kind of ordering. For example, you could say that a thread cannot lock a resource,

118
00:10:01,280 --> 00:10:06,680
unless it has already locked something which has a lower identifier and for the identifier, you could

119
00:10:06,680 --> 00:10:09,140
use names or numbers.

120
00:10:12,120 --> 00:10:18,750
The book that I recommend by Anthony Williams, it has the code for a hierarchical mutex that will

121
00:10:18,750 --> 00:10:19,470
implement this.

122
00:10:20,780 --> 00:10:24,330
I have also got a simpler example of that in the workshop for this section.

123
00:10:25,810 --> 00:10:31,390
So when you get to the end of the section and get stuck into the workshop, you will be able to do that

124
00:10:31,390 --> 00:10:31,980
for yourself.

125
00:10:36,700 --> 00:10:42,040
Deadlock is not just about looking mutexes. As we saw earlier, there are some situations, such as waiting

126
00:10:42,040 --> 00:10:44,160
for GUI events, where deadlock can occur.

127
00:10:44,680 --> 00:10:49,480
Generally, it is any situation where threads are waiting for each other, which does not necessarily

128
00:10:49,480 --> 00:10:51,060
require a lock on a mutex.

129
00:10:51,460 --> 00:10:54,520
It can also happen if the threads are calling join() on each other.

130
00:10:55,510 --> 00:11:00,190
And it can also happen if the threads are just stopping and waiting, which we will see how to do later

131
00:11:00,190 --> 00:11:00,380
on.

132
00:11:01,510 --> 00:11:07,630
So if you hold a lock, do not wait for another thread, because that thread may need the lock before

133
00:11:07,630 --> 00:11:12,340
it can do anything. In general, try to avoid waiting for threads.

134
00:11:13,530 --> 00:11:17,310
Because in that case, you will never have a situation where another thread is waiting for your thread.

135
00:11:18,360 --> 00:11:25,200
And when you create a thread, if possible, call join() in the same function where you create the

136
00:11:25,200 --> 00:11:25,950
thread instance.

137
00:11:26,970 --> 00:11:31,890
So, for example, when we create our threads in main(), we should always call join on them in main().

138
00:11:33,450 --> 00:11:35,080
OK, so that's it for this video.

139
00:11:35,520 --> 00:11:36,420
I'll see you next time.

140
00:11:36,430 --> 00:11:38,820
But meanwhile, keep coding!

