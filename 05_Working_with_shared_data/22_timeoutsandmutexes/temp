1
00:00:00,300 --> 00:00:00,870
Hello again.

2
00:00:01,140 --> 00:00:04,350
In this video, we are going to look at time outs and mutexes.
3
00:00:07,170 --> 00:00:14,160
First, we are going to take a slight diversion into recursive mutexes. Sometimes you may run into
4
00:00:14,160 --> 00:00:21,030
situations where you want to lock a mutex which is already locked, and generally you cannot do that.
5
00:00:22,300 --> 00:00:25,540
The usual result will be that the program deadlocks.
6
00:00:27,490 --> 00:00:33,610
C++ provides a recursive_mutex, which can be locked multiple times.
7
00:00:34,950 --> 00:00:42,510
So you can just call the lock function and call it again. The mutex will not actually be unlocked until
8
00:00:42,510 --> 00:00:45,870
you have done an unlock() call for every lock() call.
9
00:00:47,520 --> 00:00:52,470
If you are not sure that you're going to be able to do that manually, then you can use lock_guard, a
10
00:00:52,470 --> 00:00:57,510
unique_lock or scoped_lock to make sure that the mutex eventually gets unlocked.
11
00:00:58,920 --> 00:01:04,920
And of course, you would give recursive mutex as the parameter type for the lock
12
00:01:04,990 --> 00:01:06,120
guard or unique lock.
13
00:01:08,070 --> 00:01:13,290
Usually when you think you want to use a recursive mutex, it means there is something wrong with the
14
00:01:13,290 --> 00:01:17,180
design and you need to think a bit harder about your code.
15
00:01:17,730 --> 00:01:20,280
But there are occasionally situations where it is useful.
16
00:01:23,510 --> 00:01:28,520
I have got some code here, which is an extremely inefficient way to calculate a factorial. I am sure
17
00:01:28,520 --> 00:01:34,510
you have all seen the basic recursive implementation where you have a factorial of n.
18
00:01:34,910 --> 00:01:38,600
It calls the factorial of n minus one and multiplies the result by n.
19
00:01:39,350 --> 00:01:41,000
And that factorial(n-1)
20
00:01:41,000 --> 00:01:45,110
will call factorial(n-2) and multiply that by n minus one and so on.
21
00:01:46,690 --> 00:01:55,270
If for some bizarre reason you want to calculate a factorial in a thread and lock the recursive calls, then
22
00:01:55,330 --> 00:01:57,700
you would need to use a recursive mutex.
23
00:01:58,630 --> 00:01:59,380
So here it is.
24
00:01:59,380 --> 00:02:01,420
We have the recursive call.
25
00:02:03,350 --> 00:02:09,560
And then we lock the mutex just before we call the function recursively. I am using a lock_guard here,
26
00:02:09,950 --> 00:02:13,970
but whatever it is, there needs to be an unlock after the function returns.
27
00:02:16,010 --> 00:02:22,520
And of course, we have the terminating condition. If the argument is one or less, then we stop recursing
28
00:02:22,520 --> 00:02:26,660
and start returning and then all the locks will be unlocked.
29
00:02:28,140 --> 00:02:32,270
I have also provided a main function, which is going to call this in two separate threads.
30
00:02:33,290 --> 00:02:34,460
So let's see what happens.
31
00:02:36,910 --> 00:02:43,270
Well, the first thread has run, and then it does these calculations with the lock and it starts returning.
32
00:02:43,300 --> 00:02:46,900
So this is going to unlock, this is going to unlock and so on.
33
00:02:47,980 --> 00:02:56,200
So there we are, we have done it all, with no deadlocks. If we had used a normal mutex... (remember to
34
00:02:56,200 --> 00:02:57,160
change this one as well!)
35
00:03:01,770 --> 00:03:02,340
There we are!
36
00:03:03,200 --> 00:03:04,480
It all goes horribly wrong.
37
00:03:07,140 --> 00:03:12,930
And the reason for that is that every time we call this function, we lock the same mutex and you can
38
00:03:12,930 --> 00:03:14,190
only lock a mutex once.
39
00:03:16,340 --> 00:03:22,550
So on to timed mutexes. We have seen with plain mutexes you can either lock(), in which case the
40
00:03:23,240 --> 00:03:29,150
mutex will wait until the lock becomes available or else you can call try_lock(), which will return
41
00:03:29,150 --> 00:03:32,070
immediately, even if the lock is not available.
42
00:03:34,240 --> 00:03:40,980
There are timed mutexes. In fact, C++ has quite a zoo full of mutexes and things to do with mutexes,
43
00:03:40,990 --> 00:03:43,890
so I'm just trying to introduce them gradually.
44
00:03:45,550 --> 00:03:51,790
With a timed mutex, it has the try_lock() member function, which does not wait at all. It also has a
45
00:03:51,790 --> 00:03:59,740
try_lock_for() member function, which will wait for a certain interval, for example, 500 milliseconds.
46
00:04:00,550 --> 00:04:07,450
And a try_lock_until() member function, which will wait until a certain time point.
47
00:04:07,750 --> 00:04:10,270
So, for example, 12 seconds past the minute.
48
00:04:11,970 --> 00:04:19,830
And these have the same interface as try_lock(). If the lock is available, then it'll return true; if
49
00:04:19,830 --> 00:04:21,750
it cannot get the lock, it will return false.
50
00:04:23,900 --> 00:04:27,130
I have rewritten the program we used with try_lock().
51
00:04:28,200 --> 00:04:35,430
This time it is using try_look_for() and I have given it a duration of 100 milliseconds.
52
00:04:36,500 --> 00:04:38,330
The rest of the program is the same.
53
00:04:40,140 --> 00:04:43,290
So we have task one which locks it and sleeps.
54
00:04:45,980 --> 00:04:54,710
Task two, which tries to get the lock repeatedly. If it cannot get the lock, it tries again. And then
55
00:04:54,710 --> 00:04:57,530
a main function, which starts these two threads.
56
00:04:58,920 --> 00:04:59,790
So there we are.
57
00:05:03,740 --> 00:05:09,920
The first thread locks the mutex, then the second thread tries to get it.
58
00:05:11,500 --> 00:05:18,280
It cannot lock the mutex because the first thread has already locked it. And then it keeps trying every
59
00:05:18,280 --> 00:05:25,060
hundred milliseconds and eventually the first thread will unlock the mutex and the second thread succeeds
60
00:05:25,060 --> 00:05:26,080
in getting the lock.
61
00:05:29,800 --> 00:05:31,580
This may all sound a bit familiar.
62
00:05:31,870 --> 00:05:38,020
In fact, we have seen that unique_lock will provide this functionality for any mutex not just timed
63
00:05:38,020 --> 00:05:38,800
mutexes.
64
00:05:39,340 --> 00:05:41,890
So what is the point of having timed mutexes?
65
00:05:43,100 --> 00:05:49,460
I suppose the reason is, if you want the functionality without the extra overhead of unique_lock, you
66
00:05:49,460 --> 00:05:52,640
could use a lock_guard with a timed mutex.
67
00:05:54,630 --> 00:06:01,620
There's also a global function, try_lock(). You can pass multiple mutexes to that.
68
00:06:01,950 --> 00:06:04,640
It will try to lock them in the order that you pass them.
69
00:06:05,580 --> 00:06:10,920
If it cannot obtain all the locks, it returns immediately and it will give you a return value, which
70
00:06:10,920 --> 00:06:13,580
indicates which mutex caused the problem.
71
00:06:15,090 --> 00:06:20,400
The index is zero based, so it is zero for the first argument, one for the second and so on.
72
00:06:21,390 --> 00:06:24,690
And on success, confusingly, it returns minus one.
73
00:06:27,950 --> 00:06:36,590
How do you get these timeouts? The chrono library provides several clocks which we can use for durations and time points.
74
00:06:37,670 --> 00:06:42,890
There is a system clock which will return whatever time the operating system thinks it is.
75
00:06:44,070 --> 00:06:50,480
There are things like leap seconds which can cause the system clock to jump ahead by two seconds occasionally.
76
00:06:51,120 --> 00:06:53,610
Usually on New Year's Eve when nobody is noticing.
77
00:06:54,970 --> 00:06:59,590
It is also possible that the system time could be changed, either because someone has changed it at the
78
00:06:59,590 --> 00:07:06,610
console or there's some kind of synchronization that keeps the time in sync with an atomic clock.
79
00:07:07,740 --> 00:07:13,080
This will always return the correct time as far as the operating system is able to determine it.
80
00:07:13,710 --> 00:07:15,620
So you should use that for time points.
81
00:07:16,800 --> 00:07:22,680
There is also a steady clock, which, as the name suggests, it increases steadily. It does not go backwards,
82
00:07:22,680 --> 00:07:24,000
unlike the system clock.
83
00:07:25,050 --> 00:07:30,330
So this will always give a precise interval and we should use that for intervals.
84
00:07:32,160 --> 00:07:38,010
One other thing to bear in mind is that try_lock for() and try_ lock_until() may not actually return
85
00:07:38,010 --> 00:07:44,520
when you expect them to. They may be delayed by the scheduler if the scheduler is running something
86
00:07:44,520 --> 00:07:48,560
else, or it thinks that your thread is not sufficiently important to be woken up just yet.
87
00:07:50,090 --> 00:07:55,820
OK, so let's look at try_lock_until(). We are going to use the system clock.
88
00:07:57,340 --> 00:08:00,740
And we are going to say that we have a deadline which is 90 milliseconds from now.
89
00:08:00,760 --> 00:08:03,790
So system_clock::now() plus 90 milliseconds.
90
00:08:05,360 --> 00:08:11,830
now() will return the current time. So then this thread is going to try the lock until the deadline.
91
00:08:12,740 --> 00:08:19,490
If it fails, it will try again and it is going to keep on, missing these deadlines, until eventually it
92
00:08:19,490 --> 00:08:22,560
gets the lock. The rest of the program is exactly the same.
93
00:08:23,960 --> 00:08:27,310
So let's try that. So we get the same output.
94
00:08:27,320 --> 00:08:32,620
The first task locks the mutex, the second task keeps trying to get it.
95
00:08:33,410 --> 00:08:37,370
Eventually, the first task releases the lock and the second task can run.
96
00:08:39,840 --> 00:08:41,550
OK, so that's it for this video.
97
00:08:42,150 --> 00:08:45,000
I'll see you next time, but meanwhile, keep coding!
