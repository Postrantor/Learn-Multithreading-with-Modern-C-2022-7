WEBVTT

0
00:00.180 --> 00:03.700
Hello and welcome to my course on modern C++ concurrency.

1
00:04.170 --> 00:07.530
We're going to start off by finding out what concurrency actually means.

2
00:07.860 --> 00:10.050
So this is an introduction to concurrency.

3
00:12.050 --> 00:16.230
Concurrency generally means two or more things happening at the same time.

4
00:17.360 --> 00:23.300
So, for example, you could be watching a video on Udemy, you could be taking notes or typing code

5
00:23.300 --> 00:27.500
into a compiler, and that would be an example of human concurrency.

6
00:29.190 --> 00:34.890
In computing, it normally means that the activities are conceptually different.

7
00:35.820 --> 00:38.890
So, for example, we may have a program that takes a long time to run.

8
00:39.180 --> 00:43.590
It could be fetching data from the Internet or doing a calculation that takes a long time.

9
00:44.430 --> 00:50.700
And normally the program will provide some kind of feedback, like an hourglass or a counter to let

10
00:50.700 --> 00:53.580
you know that things are still happening and the program hasn't died.

11
00:54.900 --> 00:57.510
So that's an example of computational concurrency.

12
01:00.640 --> 01:06.460
At the operating system level, concurrency has been standard for many years. On this laptop, for

13
01:06.460 --> 01:12.210
example, which runs Windows, I have a recording program which is recording my words of wisdom.

14
01:13.330 --> 01:17.800
I have PowerPoint, which is waiting for me to go to the next slide.

15
01:18.310 --> 01:22.240
I have an e-mail program which is occasionally checking for new messages.

16
01:22.750 --> 01:28.150
I have File Explorer in case I want to open another PowerPoint presentation and so on.

17
01:29.740 --> 01:33.540
So the computer is running several different programs at the same time.

18
01:37.320 --> 01:44.280
However, until pretty recently, computers only had one processing unit, so if you only have one processor,

19
01:44.280 --> 01:47.330
how can you run several different programs at the same time?

20
01:48.120 --> 01:51.030
And the answer is something called "time slicing".

21
01:51.690 --> 01:55.050
So this means that one program gets to run for a little bit of time.

22
01:55.260 --> 01:57.530
Then it stops and another program gets to run.

23
01:57.930 --> 02:00.510
Then that one stops and something else runs and so on.

24
02:02.370 --> 02:08.400
So, for example, if I'm writing a document while I'm waiting for my compilation to finish, we could

25
02:08.400 --> 02:13.210
have a situation where the compiler gets to run for a little bit, then the email program runs and

26
02:13.320 --> 02:13.630
checks.

27
02:13.640 --> 02:20.370
If I've got any new messages, then the compiler runs again, then the word processor runs and sees if I've typed

28
02:20.370 --> 02:22.150
any more words and so on.

29
02:23.490 --> 02:28.500
And if this all happens quickly enough, it'll look to the human as though all these programs are

30
02:28.500 --> 02:29.510
running at the same time.

31
02:30.510 --> 02:36.570
It's a bit like in films where they have these frames, which are snapshots of the actors and the scenery

32
02:36.600 --> 02:37.100
and so on.

33
02:37.860 --> 02:43.620
But if you have enough of these frames appearing quickly enough, it looks as though you have continuous

34
02:43.620 --> 02:44.080
motion.

35
02:44.760 --> 02:47.120
So task switching is really an optical illusion.

36
02:50.730 --> 02:55.150
They say "there's no such thing as a free lunch", and that's true for task switching.

37
02:55.740 --> 03:01.110
The reason is that when a processor is running a program, it needs to have some information about what

38
03:01.110 --> 03:05.520
that program is doing. There are memory cells on the processor called registers.

39
03:05.970 --> 03:13.290
And these will contain the value of local variables and also things like the current stack position,

40
03:13.290 --> 03:15.840
which instruction the program is executing and so on.

41
03:18.070 --> 03:25.270
When it starts running another program, it's got to load up all this state for the new task. Processors

42
03:25.270 --> 03:30.940
also tend to have cache these days, which is used for storing the instructions and data that it's using,

43
03:30.940 --> 03:32.800
which don't fit into the registers.

44
03:34.960 --> 03:39.130
If the program has not run for a while, this is not going to be in the cache, so it has to be loaded

45
03:39.130 --> 03:39.340
up.

46
03:39.700 --> 03:41.790
So there is extra time needed to do that.

47
03:42.340 --> 03:48.310
And, while this so-called "context switch" is taking place, the processor can't execute any

48
03:48.310 --> 03:49.870
instructions for any program.

49
03:50.560 --> 03:52.340
So that slows the whole system down.

50
03:53.650 --> 03:56.560
So there is definitely overhead to task switching.

51
04:02.200 --> 04:08.650
In the modern world that we live in, computers usually have several processors, in fact, even mobile

52
04:08.650 --> 04:10.930
phones have several processors these days.

53
04:11.530 --> 04:13.270
These are known as cores.

54
04:15.000 --> 04:20.700
And when we have these cores, these multiple processing units, they can all be working away, doing

55
04:20.700 --> 04:26.010
different things at the same time, they can even run different parts of the same program at the same

56
04:26.010 --> 04:26.380
time.

57
04:27.480 --> 04:30.190
And these are all executing independently of each other.

58
04:31.470 --> 04:37.580
These are known as "hardware threads" because each core has its own "thread" of execution, if you like,

59
04:38.670 --> 04:41.610
and there's one hardware thread for each core.

60
04:45.850 --> 04:52.580
With modern operating systems, they also provide a software feature that behaves a bit like hardware

61
04:52.580 --> 04:55.030
threads and these are known as "software threads".

62
04:55.510 --> 05:01.170
So we can have a program which performs multiple activities at the same time at the software level.

63
05:03.070 --> 05:09.730
Often when we talk about "threads", we mean software threads and we use "cores" when we mean hardware

64
05:09.730 --> 05:10.120
threads.

65
05:12.430 --> 05:17.530
Usually there are more software threads than there are hardware threads or there are more threads than

66
05:17.530 --> 05:22.030
there are cores to run them, and that's not actually a problem because usually threads don't run

67
05:22.030 --> 05:22.620
all the time.

68
05:23.170 --> 05:25.060
Quite often they have to stop and wait for something.

69
05:25.330 --> 05:27.380
They may be waiting for some calculation

70
05:27.510 --> 05:30.760
that another thread is doing or they may be waiting for -

71
05:31.090 --> 05:37.090
for example, a thread that is downloading data from the Internet has to wait for the next data to arrive.

72
05:37.540 --> 05:42.070
A thread that is running Word, has to wait for the next key to be entered.

73
05:42.790 --> 05:47.410
That gives a space in which a thread isn't running, in which some other thread can run and do some useful

74
05:47.500 --> 05:47.860
work.

75
05:49.690 --> 05:54.670
These software threads are managed by the operating system, which uses time slicing.

76
06:00.010 --> 06:03.070
What support does C++ have for concurrency?

77
06:03.940 --> 06:10.660
Well, it didn't have any until 2011. Like a lot of C++ libraries, it just gives you the basics really

78
06:10.660 --> 06:14.170
to write your own library, but what it has is very efficient.

79
06:16.070 --> 06:23.600
The basic building block for C++ concurrency is the std::thread class, and this will map onto one of the

80
06:23.600 --> 06:26.690
software threads which is managed by the operating system.

81
06:29.780 --> 06:32.040
One more bit of terminology we need to clear up.

82
06:33.020 --> 06:38.330
People often talk about threads and tasks, and sometimes people think they mean the same thing.

83
06:38.990 --> 06:45.860
In this course, when I talk about threads, I mean the software threads and/or instances of the C++

84
06:46.220 --> 06:50.360
std::thread class. Tasks are higher level abstractions.

85
06:50.750 --> 06:58.010
And that's some sort of work that should be performed concurrently, usually by a thread or several

86
06:58.010 --> 06:58.400
threads.

87
07:00.210 --> 07:01.920
Okay, so that's it for this video.

88
07:02.710 --> 07:03.630
I'll see you next time.