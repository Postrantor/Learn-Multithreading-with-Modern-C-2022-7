WEBVTT

0
00:00.240 --> 00:00.820
Hello there.

1
00:01.020 --> 00:06.930
In this video, we are quickly going to go over the history of support in C++ for concurrency.

2
00:10.160 --> 00:17.690
If we go back to the very early days when the C language was developed for writing the Unix operating

3
00:17.690 --> 00:18.140
system.

4
00:19.420 --> 00:26.320
We could create a new process by calling the fork() function in the operating system API.

5
00:26.800 --> 00:33.040
This would create a new copy that was almost an exact copy of the original, except for some book keeping

6
00:33.040 --> 00:33.630
details.

7
00:36.850 --> 00:44.530
You could also create a "pipe" which allows data to flow between the parent and the child. You had the

8
00:44.530 --> 00:49.130
option to make the child process run a different program from the parent.

9
00:49.780 --> 00:53.470
So it would load up the instruction codes for a different executable.

10
00:54.580 --> 00:57.040
And in fact, that's how the Unix [command line] shell executes.

11
01:01.200 --> 01:07.170
When C++ came along, for many years, there was nothing special about C++.

12
01:07.740 --> 01:14.910
There were various ways: you could do it in C, you could still go to the Unix API or the Windows API.

13
01:15.750 --> 01:22.830
There was also a library called pthreads, which worked with POSIX systems. Which basically means Unix

14
01:22.830 --> 01:26.010
or anything that is very good at pretending to be Unix.

15
01:27.600 --> 01:34.110
And finally there is the open MP library, which was and perhaps still is very popular in numeric processing.

16
01:34.830 --> 01:41.880
So you can write code which loops over arrays. It looks like C, but it can do it in parallel so it can use

17
01:41.880 --> 01:43.530
multiple processors if you have them.

18
01:47.330 --> 01:50.120
And later, in the 1990s onwards.

19
01:51.270 --> 02:00.150
Various libraries for doing threading in C++ appeared. ACE was in the mid 90s. It is a very big, clunky library,

20
02:00.660 --> 02:05.520
mainly intended for networking, written in typical 1990s C++ code.

21
02:07.010 --> 02:13.520
The Boost library, which was developed by people who are trying to get features into C++, the library was basically

22
02:13.520 --> 02:20.060
a kind of testbed to show that these features could be developed and they were useful, and they did actually

23
02:20.060 --> 02:24.260
succeed in getting a fair number of these features added to C++ 11.

24
02:25.940 --> 02:27.560
Boost has support for threads.

25
02:28.460 --> 02:34.070
It was basically a wrapper around whatever facilities the operating system provided, but it did mean

26
02:34.070 --> 02:40.250
that you had a consistent interface and you could write the same code on anywhere that had a C++ compiler.

27
02:42.930 --> 02:48.540
And then there's also Poco, which is a more modern and lightweight version of ACE, so that is,

28
02:48.540 --> 02:51.590
again, mainly networking, but it does have thread support as well.

29
02:54.910 --> 03:02.710
And finally, 2011. This is quite ironic because when Bjarne Stroustrup first got his "C with classes"

30
03:02.830 --> 03:08.620
language working, the first thing he did was writing a task management library with coroutines.

31
03:08.930 --> 03:15.650
That was 1980, and it took another 31 years before he could get threading into the standard. Anyway,

32
03:15.670 --> 03:16.950
in C++11

33
03:17.020 --> 03:24.160
we now have a thread-safe standard library so we can use all the standard containers and algorithms with threads.

34
03:24.640 --> 03:27.910
Again, we need to be a little bit careful like we do with all data.

35
03:29.690 --> 03:32.690
It also provided a memory model and atomic operations.

36
03:33.970 --> 03:36.370
So this means that programmers can write code

37
03:37.380 --> 03:44.190
using threads, which is efficient and portable, and the behaviour of the code is well defined (unless

38
03:44.190 --> 03:48.870
you make a mistake, in which case it isn't defined, which is the same as everything else in C++.)

39
03:49.940 --> 03:55.670
And it also gives you the possibility to have fine grained control over the exact operations at low

40
03:55.670 --> 03:56.150
levels.

41
03:58.520 --> 04:03.380
And finally, which we are mainly going to concentrate on in this course, features for creating

42
04:03.380 --> 04:06.740
and managing threads which were provided in the standard library.

43
04:09.990 --> 04:19.670
Then there have been developments since then. C++14 added read-write locks. C++17 added versions of standard

44
04:19.670 --> 04:25.070
algorithms which can execute in parallel, if the hardware supports this and the compiler writers have

45
04:25.070 --> 04:25.760
implemented it.

46
04:27.350 --> 04:33.860
C++20 adds coroutines, joining threads and has better facilities for synchronizing between threads.

47
04:34.520 --> 04:36.670
So we are going to look at some of that later in the course.

48
04:37.670 --> 04:42.290
But we're only going to consider the standard C++ features in this course, so we are not going to cover

49
04:42.680 --> 04:45.200
pthreads or Boost or anything else.

50
04:46.410 --> 04:46.840
Okay.

51
04:46.910 --> 04:48.290
And that's it for this video.

52
04:48.770 --> 04:49.640
I'll see you next time.