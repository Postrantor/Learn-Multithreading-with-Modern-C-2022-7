WEBVTT

0
00:00.180 --> 00:00.750
Hello again!

1
00:00.990 --> 00:09.330
In this video, we are going to look at implementing a concurrent queue. The C++ library already provides

2
00:09.420 --> 00:12.570
an std::queue, so let's remind ourselves what that does.

3
00:13.680 --> 00:16.950
This is what is known as a first in, first out data structure.

4
00:18.540 --> 00:23.940
If you think of this as being like a queue of humans,
so they all stand there in the order that they

5
00:23.940 --> 00:26.280
arrive.
The earliest arrival

6
00:26.280 --> 00:28.920
is at the front and the latest arrival is at the back.

7
00:30.700 --> 00:35.970
In a queue data structure, elements are stored in the order they are inserted.
The oldest element goes at

8
00:35.990 --> 00:38.020
the front, the newest element goes to the back.

9
00:38.650 --> 00:43.450
Elements are said to be "pushed" onto the back of the queue and "popped" off the front.

10
00:44.860 --> 00:51.520
So elements are also removed in the order that they arrive.
In the C++ implementation,

11
00:52.030 --> 00:56.050
removing an element from the queue actually involves two separate operations.

12
00:58.120 --> 01:02.510
The first one is you call front() to get the value of the element at the front.

13
01:02.950 --> 01:04.690
This will return a reference to it.

14
01:06.600 --> 01:11.550
Then you call pop(), which will actually remove the element from the front without returning anything.

15
01:12.420 --> 01:17.230
This is different from the way that queues in most languages work.
In most languages, when you call pop(),

16
01:17.250 --> 01:20.580
it returns the value and removes the element in one single operation.

17
01:22.650 --> 01:29.700
The problem is, in C++98, that would not be exception-safe.  There were really only two options.

18
01:30.030 --> 01:36.270
One was to return the front element by reference and then when the element is removed, you then have

19
01:36.270 --> 01:38.430
a reference to something that no longer exists.

20
01:39.870 --> 01:45.840
The alternative was to return it by value, which means calling the copy constructor,
so you would make

21
01:45.840 --> 01:50.220
a copy of the value, then remove the element and then return the copy.

22
01:52.410 --> 01:57.270
The problem is that copy constructors can throw exceptions, 
and if you get an exception after

23
01:57.300 --> 02:00.600
you have removed the element, then that element is completely lost.

24
02:01.050 --> 02:02.820
There is no way that anyone can get its value.

25
02:04.250 --> 02:11.000
So that is why they had to do that way. In C++11, of course,  you can return by move,
which solves all

26
02:11.000 --> 02:13.670
these problems because move operations  cannot throw.

27
02:15.470 --> 02:19.830
Well, they should not throw!
If pop() is called on an empty container.

28
02:19.850 --> 02:27.440
the behaviour is undefined.
So you might want to pause the video for a couple of minutes and see if

29
02:27.440 --> 02:31.810
you can think of any reasons why this might be problematic in a multithreaded program.

30
02:36.580 --> 02:39.340
OK, well, I have got three reasons, or maybe two and a half.

31
02:40.330 --> 02:43.980
The first one is the library guarantees on container objects.

32
02:44.830 --> 02:49.900
If you have the same instance, which is accessed from multiple threads and there is modification, then

33
02:49.900 --> 02:51.070
there is a data race.

34
02:52.600 --> 02:55.810
So this means we cannot use a queue directly. We have to protect it.

35
02:57.040 --> 03:00.790
There is also a race condition between calling front() and calling pop()

36
03:01.120 --> 03:07.960
when we remove an element.
If we call front() and we get the value of the first element and then

37
03:07.960 --> 03:14.410
we are interrupted and some other thread runs and calls pop(), then we wake up and call pop() again.

38
03:14.890 --> 03:19.080
The element that we popped is not the one with the value that we got.

39
03:19.510 --> 03:21.610
So we have an inconsistency in our program.

40
03:23.240 --> 03:27.860
The other problematic issue is the undefined behaviour if we call pop() on an empty queue.

41
03:30.260 --> 03:36.380
So we need to implement a concurrent queue and the easiest way to do that is to write a wrapper class about the

42
03:36.380 --> 03:36.800
standard

43
03:36.800 --> 03:39.170
queue. We have a standard

44
03:39.170 --> 03:44.810
queue instance as a member of the class and we also have a mutex as another member of that class.

45
03:46.570 --> 03:51.600
The way this will work is that each of our member functions will lock the mutex,
then it will call

46
03:51.600 --> 03:58.030
the corresponding member function or member functions of the standard queue member.
And then it

47
03:58.030 --> 03:59.230
will unlock the mutex.

48
03:59.740 --> 04:06.010
So that should all be thread-safe, because only one thread can access the queue member at any one time.

49
04:07.390 --> 04:11.920
So you might like to pause the video for a couple of minutes and think about how you would implement

50
04:11.920 --> 04:14.710
this class.
How you would write the member functions?

51
04:19.970 --> 04:25.280
OK, so this is what I propose to do. For the special member functions: constructor, copy constructor,

52
04:25.370 --> 04:30.890
destructor and so on, we are just going to use the defaults,
which will call the corresponding functions

53
04:30.890 --> 04:31.860
on the data members.

54
04:33.170 --> 04:39.710
The push member function is going to lock the mutex. It will call the push member function of the standard

55
04:39.710 --> 04:40.310
queue member.

56
04:40.640 --> 04:42.680
It will pass its argument to that call.

57
04:43.550 --> 04:46.400
When that call returns, it will unlock the mutex.

58
04:48.050 --> 04:53.180
The pop member function is only a little more complex. 
It is going to lock the mutex,

59
04:54.370 --> 05:00.190
it's going to call the front member function of the queue member,
and it is going to copy the return value

60
05:00.190 --> 05:01.160
into its argument.

61
05:01.810 --> 05:06.310
This is going to take a reference to some variable of the element type.

62
05:08.580 --> 05:13.350
Then, while it is still under the lock,
it is going to call the pop member function of the queue to

63
05:13.350 --> 05:17.150
remove the element, and then when that returns, it will unlock the mutex.

64
05:18.330 --> 05:21.810
And we are also going to do something sensible if it is called on an empty queue.

65
05:23.640 --> 05:28.490
So, again, you might like to pause the video and think about what happens if there is an exception.

66
05:28.950 --> 05:31.170
Is there anything in here that can throw an exception?

67
05:31.530 --> 05:33.510
And if so, will it be safe?

68
05:36.570 --> 05:38.700
There are a couple of possibilities.

69
05:39.120 --> 05:45.630
One is when we call the queue's push(), we are going to copy the argument and that copy could throw.

70
05:45.650 --> 05:51.570
In that case, we don't actually get to call push() on the queue member,
we do not modify the queue

71
05:51.960 --> 05:54.090
and then everything is left as it was.

72
05:56.040 --> 06:02.880
And then if we use some wrapper objects like the lock guard or unique lock, the mutex will be automatically unlocked

73
06:02.880 --> 06:04.170
when the destructors are called.

74
06:06.000 --> 06:11.600
In the pop function, we again have a copy constructor.
In that case, all that we have done is to call

75
06:11.610 --> 06:16.060
the front member function. We have just looked at the first element in the queue.

76
06:16.860 --> 06:18.360
We do not actually get to call pop.

77
06:18.390 --> 06:20.220
So, again, the queue is unmodified.

78
06:21.540 --> 06:27.720
So that does not actually affect anything.
And the mutex will be automatically unlocked when the destructors

79
06:27.720 --> 06:28.140
are called.

80
06:29.220 --> 06:31.980
So we have actually provided the strong exception guarantee.

81
06:32.280 --> 06:35.850
If an exception is thrown, then everything will be left as it was.

82
06:39.170 --> 06:45.590
OK, so here is our class definition. We are going to make it a template class so we can store any type

83
06:45.590 --> 06:46.680
of element inside it.

84
06:47.840 --> 06:57.350
We have a mutex and a queue as members. We are going to use the defaults for the special functions. I put

85
06:57.350 --> 07:00.170
the constructor in just to make it obvious that we have not forgotten.

86
07:03.420 --> 07:10.290
The push member function is going to lock the mutex using a lock guard, and it is going to call push on the

87
07:10.290 --> 07:11.170
underlying queue.

88
07:11.490 --> 07:14.600
It will pass the argument that we are pushing onto the queue.

89
07:15.600 --> 07:18.120
And then when this returns, the mutex will be unlocked.

90
07:20.250 --> 07:27.060
The function will again lock the mutex. We check if the queue is empty and if it is, we throw an exception.

91
07:29.220 --> 07:31.890
If the queue is not empty, we are still under the lock,

92
07:31.900 --> 07:34.350
so no one else can come along and modify the queue.

93
07:34.890 --> 07:41.580
And then we get the front element and we remove the element from the queue,
and then the mutex will be

94
07:41.580 --> 07:42.060
unlocked.

95
07:46.260 --> 07:51.840
The exception that we throw is just a very simple one derived from the standard exception. We provide

96
07:51.840 --> 07:54.900
a couple of constructors which are needed for making it compile.

97
08:00.450 --> 08:09.330
I have also got a program to test it. So we create an instance of our concurrent queue.
There is a thread which

98
08:09.330 --> 08:12.040
is going to call pop.

99
08:12.060 --> 08:14.250
This is going to read data off the queue.

100
08:16.030 --> 08:17.050
There is the call to pop.

101
08:20.340 --> 08:22.680
I put some print statements in, so we can see what is going on.

102
08:22.980 --> 08:28.710
I have also put a try/catch block around it, just in case it does throw when we access an empty queue.

103
08:30.820 --> 08:33.130
There is a writer thread, which is going to call push.

104
08:37.100 --> 08:41.510
And then in the main function, we launch these threads and we wait for them.

105
08:44.820 --> 08:49.770
So we start by creating the writer thread. This is going to push some data onto the queue,
and then

106
08:49.770 --> 08:55.040
the reader will call pop and get the data. That is all

107
08:55.050 --> 08:55.440
Okay.

108
08:59.780 --> 09:04.640
Now, if I move this sleep statement out of the main and into the writer thread.

109
09:07.240 --> 09:12.850
So this means the writer thread is going to sleep before it pushes anything onto the queue,
and that

110
09:12.850 --> 09:15.780
means when the reader thread starts, it is going to see an empty queue.

111
09:16.210 --> 09:18.070
So let's see how it handles this.

112
09:21.540 --> 09:29.250
So the reader thread starts up, there is nothing on the queue, and then we get the empty queue exception.
And eventually

113
09:29.250 --> 09:33.560
the writer thread wakes up, it calls push, but there is nobody there to read it.

114
09:38.590 --> 09:43.780
We are throwing an exception when the queue is empty, which is better than doing - who knows what?
But

115
09:43.780 --> 09:44.890
we could improve this.

116
09:47.040 --> 09:51.990
This is a multithreaded program, so it is possible that if we hang around for a while,
some other thread

117
09:51.990 --> 09:56.700
will come along and push some data onto the queue, and then it will be safe for us to pop it.

118
09:58.660 --> 10:05.770
So instead of throwing an exception, we can wait until the queue becomes populated.
And we can do that

119
10:05.770 --> 10:11.350
with a condition variable. In the thread that calls pop, we don't call pop straight away.

120
10:11.380 --> 10:13.070
We call wait on the condition variable

121
10:13.090 --> 10:19.690
first.
In the thread that calls push, we notify the condition variable and then that will wake up the thread

122
10:19.690 --> 10:25.660
that calls pop.
And then it will be able to go ahead and actually do the pop operation.

123
10:27.580 --> 10:32.180
We saw when we looked at condition variables, that there can be spurious and lost wake ups.

124
10:32.530 --> 10:38.200
In fact, we saw one just then. A lost wake up where the reader thread ran before there was any data.

125
10:40.330 --> 10:46.480
And we can avoid that by adding a predicate argument when we call wait.
This predicate is going to

126
10:46.480 --> 10:47.200
check the queue.

127
10:47.740 --> 10:50.350
If the queue is empty, then we continue waiting.

128
10:51.880 --> 10:57.730
If the queue is not empty, then it is safe for us to continue and pop the data off the queue.

129
10:59.230 --> 11:02.200
So you might like to pause the video and have a go at implementing this.

130
11:08.390 --> 11:11.600
Right, so we have modified the class definition slightly.

131
11:11.980 --> 11:14.650
We have added a condition variable as a member.

132
11:17.510 --> 11:24.320
And then when we call push, we notify the condition variable, so that will signal that there is data.

133
11:24.320 --> 11:28.990
And threads which are waiting to read, will be able to wake up and read the data.

134
11:32.150 --> 11:35.930
In the pop member function, we have a call to wait.

135
11:38.030 --> 11:45.230
And then we have a predicate function which is going to check the queue member. It is going to call the empty()

136
11:45.230 --> 11:46.070
member function of this

137
11:46.070 --> 11:54.200
queue.
And if this member function returns true, the queue is still empty and we continue waiting.

138
11:54.710 --> 11:57.290
If it returns false, then we can proceed

139
11:57.650 --> 11:59.330
and get the data off the queue.

140
12:04.320 --> 12:06.670
And the test program is the same as before.

141
12:07.320 --> 12:08.630
So let's try this out.

142
12:12.130 --> 12:18.330
So we have our reader thread, which is waiting for data. Then the writer thread writes the data. It notifies

143
12:18.340 --> 12:23.500
the condition variable,
then the condition variable wakes up the reader thread and the reader thread

144
12:23.560 --> 12:24.670
can get the data.

145
12:35.870 --> 12:41.960
So in conclusion, this is a fairly simple concurrent queue.
It is an example of what is known as

146
12:41.960 --> 12:48.500
coarse-grained locking,
which means that the entire data structure is locked and only one thread can

147
12:48.500 --> 12:50.060
access the queue at any one time.

148
12:51.350 --> 12:55.790
So in effect, when the program accesses the queue, it becomes single threaded.

149
12:58.040 --> 13:03.820
Adding the condition variable makes the program more flexible and also makes it slightly less coarse-grained.

150
13:04.730 --> 13:10.280
If we have an empty queue and a thread that is trying to call pop, then other threads will be able to run and

151
13:10.280 --> 13:11.510
call member functions.

152
13:11.630 --> 13:17.330
For example, they could query the size of the queue.
And that can carry on until some data is pushed

153
13:17.330 --> 13:17.840
in the queue.

154
13:18.680 --> 13:22.520
And then it goes back to being single-threaded again, so that the thread can safely call pop.

155
13:24.390 --> 13:30.720
A more efficient solution would be to use lock-free programming,
which would allow more threads

156
13:30.720 --> 13:36.090
to access the queue, provided they are doing different things
and it would also be more efficient because

157
13:36.090 --> 13:38.540
locking mutexes is very time consuming.

158
13:39.390 --> 13:42.210
Unfortunately, lock-free programming is much more difficult.

159
13:42.570 --> 13:44.460
So that would have to wait for another course.

160
13:46.580 --> 13:48.530
Okay, so that's it for this video.

161
13:48.680 --> 13:49.620
I'll see you next time.

162
13:49.640 --> 13:51.740
But meanwhile, keep coding!